<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网页静态化</title>
    <url>/blog/posts/3337808701/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><h1>网页静态化</h1><h2 id="简介">简介</h2><div class="spoiler collapsed"><div class="spoiler-title">简介</div><div class="spoiler-content"><p>随着网站的内容的增多和用户访问量的增多，无可避免的是网站加载会越来越慢，受限于带宽和服务器同一时间的请求次数的限制，我们往往需要在此时对我们的网站进行代码优化和服务器配置的优化。<br><strong>一般情况下会从以下方面来做优化</strong></p><ul><li>动态页面静态化</li><li>优化数据库</li><li>使用负载均衡</li><li>使用缓存</li><li>使用CDN加速</li></ul><p>此文以乐优电商网站为例（处理高并发问题)</p><p>​	我们的页面是通过Thymeleaf模板引擎渲染后返回到客户端。在后台需要大量的数据查询，而后渲染得到HTML页面。会对数据库造成压力，并且请求的响应时间过长，并发能力不高。</p><p>大家能想到什么办法来解决这个问题？</p><p>首先我们能想到的就是缓存技术，比如Redis。不过Redis适合数据规模比较小的情况。假如数据量比较大，例如我们的商品详情页。每个页面如果10kb，100万商品，就是10GB空间，对内存占用比较大。此时就给缓存系统带来极大压力，如果缓存崩溃，接下来倒霉的就是数据库了。</p><p>所以缓存并不是万能的，某些场景需要其它技术来解决，比如静态化。</p></div></div><a id="more"></a><!-- more --><h3 id="什么是静态化">什么是静态化</h3><p>​	静态化是指把动态生成的HTML页面变为静态内容保存，以后用户的请求到来，直接访问静态页面，不再经过服务的渲染。</p><p>静态处理后又给网站带来了哪些好处？</p><ul><li>静态页面相对于动态页面更容易被搜索引擎收录。</li><li>访问静态页面不需要经过程序处理，因此可以提高运行速度。</li><li>减轻服务器负担。</li><li>静态的HTML页面可以部署在nginx中，从而大大提高并发能力</li></ul><h3 id="如何实现静态化">如何实现静态化</h3><p>目前，静态化页面都是通过模板引擎来生成，而后保存到nginx服务器来部署。常用的模板引擎比如：</p><ul><li>Freemarker</li><li>Velocity</li><li>Thymeleaf</li></ul><p>我们之前就使用的Thymeleaf，来渲染html返回给用户。Thymeleaf除了可以把渲染结果写入Response，也可以写到本地文件，从而实现静态化。</p><h2 id="Thymeleaf实现静态化">Thymeleaf实现静态化</h2><h3 id="概念">概念</h3><p>先说下Thymeleaf中的几个概念：</p><ul><li>Context：运行上下文</li><li>TemplateResolver：模板解析器</li><li>TemplateEngine：模板引擎</li></ul><blockquote><p>Context</p></blockquote><p>上下文： 用来保存模型数据，当模板引擎渲染时，可以从Context上下文中获取数据用于渲染。</p><p>当与SpringBoot结合使用时，我们放入Model的数据就会被处理到Context，作为模板渲染的数据使用。</p><blockquote><p>TemplateResolver</p></blockquote><p>模板解析器：用来读取模板相关的配置，例如：模板存放的位置信息，模板文件名称，模板文件的类型等等。</p><p>当与SpringBoot结合时，TemplateResolver已经由其创建完成，并且各种配置也都有默认值，比如模板存放位置，其默认值就是：templates。比如模板文件类型，其默认值就是html。</p><blockquote><p>TemplateEngine</p></blockquote><p>模板引擎：用来解析模板的引擎，需要使用到上下文、模板解析器。分别从两者中获取模板中需要的数据，模板文件。然后利用内置的语法规则解析，从而输出解析后的文件。来看下模板引擎进行处理的函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">templateEngine.process(<span class="string">"模板名"</span>, context, writer);</span><br></pre></td></tr></table></figure><p>三个参数：</p><ul><li>模板名称</li><li>上下文：里面包含模型数据</li><li>writer：输出目的地的流</li></ul><p>在输出时，我们可以指定输出的目的地，如果目的地是Response的流，那就是网络响应。如果目的地是本地文件，那就实现静态化了。</p><p>而在SpringBoot中已经自动配置了模板引擎，因此我们不需要关心这个。现在我们做静态化，就是把输出的目的地改成本地文件即可！</p><h3 id="具体实现">具体实现</h3><p><img src="http://qaghauodb.bkt.clouddn.com/Bolg/1532757937331.png" alt></p><h5 id="Service代码：">Service代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsHtmlService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsService goodsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(GoodsHtmlService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建html页面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> spuId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createHtml</span><span class="params">(Long spuId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取页面数据</span></span><br><span class="line">            Map&lt;String, Object&gt; spuMap = <span class="keyword">this</span>.goodsService.loadModel(spuId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建thymeleaf上下文对象</span></span><br><span class="line">            Context context = <span class="keyword">new</span> Context();</span><br><span class="line">            <span class="comment">// 把数据放入上下文对象</span></span><br><span class="line">            context.setVariables(spuMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建输出流</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"C:\\project\\nginx-1.14.0\\html\\item\\"</span> + spuId + <span class="string">".html"</span>);</span><br><span class="line">            writer = <span class="keyword">new</span> PrintWriter(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行页面静态化方法</span></span><br><span class="line">            templateEngine.process(<span class="string">"item"</span>, context, writer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"页面静态化出错：&#123;&#125;，"</span>+ e, spuId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建线程处理页面静态化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> spuId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncExcute</span><span class="params">(Long spuId)</span> </span>&#123;</span><br><span class="line">        ThreadUtils.execute(()-&gt;createHtml(spuId));</span><br><span class="line">        <span class="comment">/*ThreadUtils.execute(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                createHtml(spuId);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程工具类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        es.submit(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么时候创建静态文件">什么时候创建静态文件</h3><p>我们编写好了创建静态文件的service，那么问题来了：什么时候去调用它呢</p><p>想想这样的场景：</p><p>​	假如大部分的商品都有了静态页面。那么用户的请求都会被nginx拦截下来，根本不会到达我们的<code>leyou-goods-web</code>服务。只有那些还没有页面的请求，才可能会到达这里。</p><p>因此，如果请求到达了这里，我们除了返回页面视图外，还应该创建一个静态页面，那么下次就不会再来麻烦我们了。</p><p>所以，我们在GoodsController中添加逻辑，去生成静态html文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;.html"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toItemPage</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id, Model model)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载所需的数据</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">this</span>.goodsService.loadModel(id);</span><br><span class="line">    <span class="comment">// 把数据放入数据模型</span></span><br><span class="line">    model.addAllAttributes(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面静态化</span></span><br><span class="line">    <span class="keyword">this</span>.goodsHtmlService.asyncExcute(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"item"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：生成html 的代码不能对用户请求产生影响，所以这里我们使用额外的线程进行异步创建。</p><h3 id="重启测试：">重启测试：</h3><p>访问一个商品详情，然后查看nginx目录：</p><p><img src="http://qaghauodb.bkt.clouddn.com/Bolg/1532757980379.png" alt></p><h2 id="nginx代理静态页面">nginx代理静态页面</h2><p>接下来，我们修改nginx，让它对商品请求进行监听，指向本地静态页面，如果本地没找到，才进行反向代理：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.leyou.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-Server <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /item &#123;</span><br><span class="line">        <span class="comment"># 先找本地</span></span><br><span class="line">        <span class="attribute">root</span> html;</span><br><span class="line">        <span class="attribute">if</span> (!-f <span class="variable">$request_filename</span>) &#123; <span class="comment">#请求的文件不存在，就反向代理</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8084;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:9002;</span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启测试：</p><p>发现请求速度得到了极大提升：</p><p><img src="http://qaghauodb.bkt.clouddn.com/Bolg/1532758206086.png" alt></p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网页静态化技术</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用及介绍</title>
    <url>/blog/posts/2980727567/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:51 GMT+0800 (GMT+08:00) --><h2 id="Docker简介">Docker简介</h2><h3 id="1-1-什么是虚拟化">1.1 什么是虚拟化</h3><div class="spoiler collapsed"><div class="spoiler-title">什么是虚拟化</div><div class="spoiler-content"><p>​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p><p>在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用</p><p>虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p></div></div><a id="more"></a><!-- more --><h3 id="1-2-什么是Docker">1.2 什么是Docker</h3><p>​	Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。</p><p><img src="https://img-blog.csdnimg.cn/20181219142029741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5ajIwMThneXE=,size_16,color_FFFFFF,t_70" alt="å¨è¿éæå¥å¾çæè¿°">	Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p><p>​	Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p><p>​	在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p><p>​	Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><h3 id="1-3-为什么选择Docker">1.3 为什么选择Docker?</h3><ol><li><h5 id="上手快。">上手快。</h5><p>用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p></li><li><h5 id="职责的逻辑分类"><strong>职责的逻辑分类</strong></h5><p>使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p></li><li><h5 id="快速高效的开发生命周期"><strong>快速高效的开发生命周期</strong></h5><p>Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p></li><li><p><strong>鼓励使用面向服务的架构</strong></p><p>Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p></li></ol><h2 id="2-搭建Docker">2.搭建Docker</h2><h5 id="环境准备">环境准备</h5><p>​	操作系统：Linux（RHEL、Centos、Ubuntu） / Windows(windows7.1、windows 8)+VM+处理器需要支持硬件虚拟化</p><p>本次演示使用的阿理ESC服务器：CentOS 7.6 64位</p><h5 id="安装">安装</h5><p>​	Centos可以选择从yum仓库安装docker。</p><p>​	安装命令：<strong>yum install docker</strong> 然后等安装完毕</p><p><strong>启动：service docker start</strong></p><p><strong>设置为开机启动命令</strong>：</p><p><strong>systemctl start docker</strong></p><p><strong>systemctl enable docker</strong></p><p><strong>查看状态：</strong> <strong>service docker status</strong></p><p><strong>停止：service docker stop</strong></p><p><strong>停止所有容器：docker stop $(docker ps -aq)</strong></p><h2 id="3-安装一个官方镜像">3.安装一个官方镜像</h2><p>查找可用的镜像：<strong>docker search portainer</strong> （search后面跟要搜索的镜像名字）</p><p>拉取：<strong>docker pull portainer/portainer</strong></p><p>注：在docker的镜像索引网站上面，镜像都是按照“用户名/镜像名”的方式来存储的。有一组比较特殊的镜像，比如ubuntu这类基础镜像，经过官方的验证，值得信任，可以直接用 镜像名来检索到。</p><h3 id="3-1、切换镜像仓库地址">3.1、切换镜像仓库地址</h3><p>将镜像仓库地址切到国内，速度会有些提升。</p><p>如下：修改/etc/docker/daemon.json</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他镜像Docker 官方中国区：<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></p><p>网易：<a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a></p><p>ustc：<a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p><h2 id="4-使用Docker">4.使用Docker</h2><p>使用Docker的好处：</p><p>​	简化配置</p><p>​	代码流水线（Code Pipeline）管理</p><p>​	提高开发运维效率</p><p>​	整合服务器</p><p>​	资源隔离低消耗</p><p>​	快速部署</p><h4 id="应用部署">应用部署</h4><h5 id="MySQL部署">MySQL部署</h5><ol><li><p>拉取mysql镜像</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker pull centos/mysql<span class="number">-57</span>-centos7</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=tensquare_mysql -p 33306:3306 -e <span class="attribute">YSQL_ROOT_PASSWORD</span>=123456 mysql</span><br></pre></td></tr></table></figure><p>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码</p></li><li><p>远程登录mysql</p><p>连接宿主机的IP ,指定端口为33306</p></li></ol><h5 id="Tomcat部署">Tomcat部署</h5><ol><li>拉取镜像</li></ol><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker pull tomcat:<span class="number">7</span>-jre7</span><br></pre></td></tr></table></figure><ol start="2"><li>创建容器 -p表示地址映射</li></ol><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -di --name=mytomcat -p 9000:8080 -v /usr/<span class="built_in">local</span>/webapps:/usr/<span class="built_in">local</span>/tomcat/webapps tomcat:7-jre7</span></span><br></pre></td></tr></table></figure><h5 id="Nginx部署">Nginx部署</h5><ol><li><p>拉取镜像</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull nginx</span></span><br></pre></td></tr></table></figure></li></ol><p>4.3 Nginx部署</p><ol><li><p>拉取镜像</p></li><li><p>创建Nginx容器</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure></li></ol><h5 id="Redis部署">Redis部署</h5><ol><li><p>拉取镜像</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull redis</span></span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -di <span class="attribute">--name</span>=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></li></ol><h4 id="可视化管理Docker-UI">可视化管理Docker UI</h4><p>以portainer、rancher为例</p><ol><li><p>拉取镜像</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">docker</span> pull portainer/portainer</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">docker run -it --name docker-portainer -d -p <span class="number">9000</span>:<span class="number">9000</span> -v <span class="regexp">/var/</span>run<span class="regexp">/docker.sock:/</span>var<span class="regexp">/run/</span>docker.sock -v <span class="string">portainer_data:</span><span class="regexp">/data portainer/</span>portainer</span><br></pre></td></tr></table></figure></li></ol><p>检查端口是否启起来。</p><p><strong>此时因为使用阿里云ESC服务器需要配置安全组策略</strong></p><p><img src="http://qaghauodb.bkt.clouddn.com/Bolg/1.png" alt="1574047426360"></p><p>然后宿主机，输入：<a href="http://172.22.144.238:9000/" target="_blank" rel="noopener">http://172.22.144.238:9000/</a> ，创建用户密码，密码至少为8位，比如：12345678，进入页面后，选择local environment。</p><h2 id="5-Docker常用命令">5.Docker常用命令</h2><p><strong>docker ps</strong> 显示正在运行的容器</p><p><strong>docker ps -a</strong> 显示所有的容器</p><p><strong>docker ps -l</strong> 显示最近一次运行的容器</p><p><strong>docker image ls</strong> 列出已安装的顶层镜像</p><p><strong>docker images xxx</strong> 列出已安装的指定的某个镜像，xxx代表镜像名字，支持通配符</p><p><strong>docker images -q</strong> 列出已安装的镜像ID</p><p><strong>docker search xxx</strong> 搜索镜像名，xxx代表镜像名字，支持通配符</p><p><strong>docker pull redis:3.0.7</strong> 下载redis镜像，版本是3.0.7，如果不带:和3.0.7则默认下载最新版本</p><p><strong>docker rm 容器名/容器ID</strong> 删除指定的容器</p><p><strong>docker rm $(docker ps -a -q)</strong> 慎用！删除所有停止运行的容器</p><p>docker run 容器名 env 等于：查看指定容器的环境变量</p><p>docker images -viz | dot -T png -o docker.png 生成容器依赖关系图</p><p>docker run -it 容器名</p><p>docker run &lt;=&gt; 先docker create 再 docker start -it表示后台服务挂起</p><p><strong>docker stop containerID</strong> 停止指定的容器</p><p><strong>docker start containerID</strong> 启动指定容器</p><p>docker exec -it containerID /bin/bash 进入指定的容器的命令行</p><p>docker inspect -f=’{ {.Name} }’ $(docker ps -a -q) 查看容器的名称</p><p>docker inspect -f=’{ {.NetworkSettings.IPAddress} }’ $(sudo docker ps -a -q)	查看容器的名IP</p><p>docker inspect 容器ID<br>docker inspect 容器ID | grep IPAddres	从显示信息中可以看到IP</p><p><strong>docker run --name container-name -d image-name</strong> 运行一个image-name镜像的一个实例，名为container-name</p><p>docker run -d -p [本机端口]:[docker服务器端口] --name container-name image-name	启动容器时，指定主机与容器的IP映射关系</p><p>docker logs firstmysql	查看容器firstmysql的日志</p><p>docker run --name firstmysql -p 3306:13306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</p><p>启动mysql的镜像，生成一个容器，3306是本地端口，13306是容器中的端口，两者可一样，123456是mysql的root密码，latest表示mysql镜像的版本号，latest表示最新版本。</p><p>docker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server --appendonly yes</p><h2 id="6-常见问题">6.常见问题</h2><p><strong>6.1 连不上docker官方仓库</strong></p><p>国外网络有时访问比较慢，可以切到国内镜像仓库。</p><p><strong>6.2 启动mysql容器后，使用客户端连不上，报ERROR 2059 (HY000)</strong></p><blockquote><p>ERROR 2059 (HY000): Authentication plugin ‘caching_sha2_password’ cannot be loaded: /usr/lib64/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory</p></blockquote><p>原因：指定了加密方式则可能在客户端连接时有问题</p><p>解决方案：</p><p>1.进入mysql容器</p><p>​	docker exec -it hello-mysql /bin/bash</p><p>2.进入mysql</p><p>​	mysql -uroot -p123456</p><p>3.修改密码</p><p>​	ALTER USER ‘root’@’%’ IDENTIFIED WITH mysql_native_password BY ‘root’;</p><p>​	或：</p><p>​	update mysql.user set password=PASSWORD(“pwd”) where User=‘root’;</p><blockquote><p>报错：ERROR 1045 (28000): Access denied for user ‘root’@‘172.17.0.1’ (using password: NO)</p></blockquote><p>原因：主机没有访问容器数据库的权限</p><p>方法：</p><p>use mysql;</p><p>update user u set u.host = ‘%’ where u.user = ‘root’ limit 1;</p><p>flush privileges;</p><p>如果客户端无法telnet容器，则需要关闭容器的防火墙</p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>容器化技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Thymeleaf语法入门</title>
    <url>/blog/posts/3800349728/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><h2 id="1-Thymeleaf简介">1.Thymeleaf简介</h2><div class="spoiler collapsed"><div class="spoiler-title">简介</div><div class="spoiler-content"><p>官方网站：<a href="https://www.thymeleaf.org/index.html" target="_blank" rel="noopener">https://www.thymeleaf.org/index.html</a></p><p><img src="https://img-blog.csdnimg.cn/20191119180117653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Thymeleaf</strong>是用来开发Web和独立环境项目的现代服务器端Java模板引擎。</p><p>Thymeleaf的主要目标是为您的开发工作流程带来优雅的<em>自然模板</em> - HTML。可以在直接浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。</p><p>借助Spring Framework的模块，可以根据自己的喜好进行自由选择，可插拔功能组件，Thymeleaf是现代HTML5 JVM Web开发的理想选择 - 尽管它可以做的更多。</p><p>Spring官方支持的服务的渲染模板中，并不包含jsp。而是Thymeleaf和Freemarker等，而Thymeleaf与SpringMVC的视图技术，及SpringBoot的自动化配置集成非常完美，几乎没有任何成本，你只用关注Thymeleaf的语法即可。</p></div></div><a id="more"></a><!-- more --><h2 id="2-特点">2.特点</h2><p>特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><h2 id="3-环境准备">3.环境准备</h2><p>我们来创建一个module，为学习Thymeleaf做准备：</p><h3 id="3-1-创建module">3.1.创建module</h3><p>使用spring 脚手架创建：</p><p><img src="https://img-blog.csdnimg.cn/20191119180137645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191119180156656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>勾选web和Thymeleaf的依赖：</p><p><img src="https://img-blog.csdnimg.cn/20191119180213299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>项目结构：</p><p><img src="https://img-blog.csdnimg.cn/2019111918022620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>pom：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>thymeleaf-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-默认配置">3.2.默认配置</h3><p>不需要做任何配置，启动器已经帮我们把Thymeleaf的视图器配置完成：</p><p><img src="https://img-blog.csdnimg.cn/2019111918024442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>而且，还配置了模板文件（html）的位置，与jsp类似的前缀+ 视图名 + 后缀风格：</p><p><img src="https://img-blog.csdnimg.cn/20191119180331108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>Thymeleaf默认会开启页面缓存，提高页面并发能力。但会导致我们修改页面不会立即被展现，因此我们关闭缓存：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭Thymeleaf的缓存</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>另外，修改完毕页面，需要使用快捷键：<code>Ctrl + Shift + F9</code>来刷新工程。</p><h3 id="3-3-快速开始">3.3.快速开始</h3><p>我们准备一个controller，控制视图跳转：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"show1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show1</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"msg"</span>, <span class="string">"Hello, Thymeleaf!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个html模板：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span>&gt;</span>大家好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><p>启动项目，访问页面：</p><p><img src="https://img-blog.csdnimg.cn/2019111918035722.png" alt="在这里插入图片描述"></p><h2 id="4-语法">4.语法</h2><p>Thymeleaf的主要作用是把model中的数据渲染到html中，因此其语法主要是如何解析model中的数据。从以下方面来学习：</p><ul><li>变量</li><li>方法</li><li>条件判断</li><li>循环</li><li>运算<ul><li>逻辑运算</li><li>布尔运算</li><li>比较运算</li><li>条件运算</li></ul></li><li>其它</li></ul><h3 id="4-1-变量">4.1.变量</h3><h4 id="变量案例">变量案例</h4><p>我们先新建一个实体类：User</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    User friend;<span class="comment">// 对象类型属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在模型中添加数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"show2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    user.setName(<span class="string">"Jack Chen"</span>);</span><br><span class="line">    user.setFriend(<span class="keyword">new</span> User(<span class="string">"李小龙"</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"show2"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>语法说明：</p></blockquote><p>Thymeleaf通过<code>${}</code>来获取model中的变量，注意这不是el表达式，而是ognl表达式，但是语法非常像。</p><blockquote><p>示例：</p></blockquote><p>我们在页面获取user数据：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    欢迎您：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>请登录<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/20191119180414215.png" alt="在这里插入图片描述"></p><p>感觉跟el表达式几乎是一样的。不过区别在于，我们的表达式写在一个名为：<code>th:text</code>的标签属性中，这个叫做<code>指令</code></p><h4 id="动静结合">动静结合</h4><blockquote><p>指令：</p></blockquote><p>Thymeleaf崇尚<code>自然模板</code>，意思就是模板是纯正的html代码，脱离模板引擎，在纯静态环境也可以直接运行。现在如果我们直接在html中编写 <code>${}</code>这样的表达式，显然在静态环境下就会出错，这不符合Thymeleaf的理念。</p><p>Thymeleaf中所有的表达式都需要写在<code>指令</code>中，指令是HTML5中的自定义属性，在Thymeleaf中所有指令都是以<code>th:</code>开头。因为表达式<code>${user.name}</code>是写在自定义属性中，因此在静态环境下，表达式的内容会被当做是普通字符串，浏览器会自动忽略这些指令，这样就不会报错了！</p><p>现在，我们不经过SpringMVC，而是直接用浏览器打开页面看看：</p><p><img src="https://img-blog.csdnimg.cn/2019111918042993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>静态页面中，<code>th</code>指令不被识别，但是浏览器也不会报错，把它当做一个普通属性处理。这样<code>span</code>的默认值<code>请登录</code>就会展现在页面</li><li>如果是在Thymeleaf环境下，<code>th</code>指令就会被识别和解析，而<code>th:text</code>的含义就是替<strong>换所在标签中的文本内容</strong>，于是<code>user.name</code>的值就替代了 <code>span</code>中默认的请登录</li></ul><p>指令的设计，正是Thymeleaf的高明之处，也是它优于其它模板引擎的原因。动静结合的设计，使得无论是前端开发人员还是后端开发人员可以完美契合。</p><blockquote><p>向下兼容</p></blockquote><p>但是要注意，如果浏览器不支持Html5怎么办？</p><p>如果不支持这种<code>th:</code>的命名空间写法，那么可以把<code>th:text</code>换成 <code>data-th-text</code>，Thymeleaf也可以兼容。</p><blockquote><p>escape</p></blockquote><p>另外，<code>th:text</code>指令出于安全考虑，会把表达式读取到的值进行处理，防止html的注入。</p><p>例如，<code>&lt;p&gt;你好&lt;/p&gt;</code>将会被格式化输出为<code>$lt;p$gt;你好$lt;/p$lt;</code>。</p><p>如果想要不进行格式化输出，而是要输出原始内容，则使用<code>th:utext</code>来代替.</p><h4 id="ognl表达式的语法">ognl表达式的语法</h4><p>刚才获取变量值，我们使用的是经典的<code>对象.属性名</code>方式。但有些情况下，我们的属性名可能本身也是变量，怎么办？</p><p>ognl提供了类似js的语法方式：</p><p>例如：<code>${user.name}</code> 可以写作<code>${user['name']}</code></p><h3 id="4-2-自定义变量">4.2.自定义变量</h3><blockquote><p>场景</p></blockquote><p>看下面的案例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;"</span>&gt;</span>21<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>friend: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.friend.name&#125;"</span>&gt;</span>Rose<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们获取用户的所有信息，分别展示。</p><p>当数据量比较多的时候，频繁的写<code>user.</code>就会非常麻烦。</p><p>因此，Thymeleaf提供了自定义变量来解决：</p><blockquote><p>示例：</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:object</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;name&#125;"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;age&#125;"</span>&gt;</span>21<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>friend: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;friend.name&#125;"</span>&gt;</span>Rose<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>首先在 <code>h2</code>上 用 <code>th:object=&quot;${user}&quot;</code>获取user的值，并且保存</li><li>然后，在<code>h2</code>内部的任意元素上，可以通过 <code>*{属性名}</code>的方式，来获取user中的属性，这样就省去了大量的<code>user.</code>前缀了</li></ul><h3 id="4-3-方法">4.3.方法</h3><blockquote><p>ognl表达式中的方法调用</p></blockquote><p>ognl表达式本身就支持方法调用，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:object</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>FirstName: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;name.split(' ')[0]&#125;"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>LastName: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;name.split(' ')[1]&#125;"</span>&gt;</span>Li<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这里我们调用了name（是一个字符串）的split方法。</li></ul><blockquote><p>Thymeleaf内置对象</p></blockquote><p>Thymeleaf中提供了一些内置对象，并且在这些对象中提供了一些方法，方便我们来调用。获取这些对象，需要使用<code>#对象名</code>来引用。</p><ul><li>一些环境相关对象</li></ul><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>#ctx</code></td><td style="text-align:left">获取Thymeleaf自己的Context对象</td></tr><tr><td style="text-align:center"><code>#requset</code></td><td style="text-align:left">如果是web程序，可以获取HttpServletRequest对象</td></tr><tr><td style="text-align:center"><code>#response</code></td><td style="text-align:left">如果是web程序，可以获取HttpServletReponse对象</td></tr><tr><td style="text-align:center"><code>#session</code></td><td style="text-align:left">如果是web程序，可以获取HttpSession对象</td></tr><tr><td style="text-align:center"><code>#servletContext</code></td><td style="text-align:left">如果是web程序，可以获取HttpServletContext对象</td></tr><tr><td style="text-align:center"></td><td style="text-align:left"></td></tr></tbody></table><ul><li>Thymeleaf提供的全局对象：</li></ul><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>#dates</code></td><td style="text-align:left">处理java.util.date的工具对象</td></tr><tr><td style="text-align:center"><code>#calendars</code></td><td style="text-align:left">处理java.util.calendar的工具对象</td></tr><tr><td style="text-align:center"><code>#numbers</code></td><td style="text-align:left">用来对数字格式化的方法</td></tr><tr><td style="text-align:center"><code>#strings</code></td><td style="text-align:left">用来处理字符串的方法</td></tr><tr><td style="text-align:center"><code>#bools</code></td><td style="text-align:left">用来判断布尔值的方法</td></tr><tr><td style="text-align:center"><code>#arrays</code></td><td style="text-align:left">用来护理数组的方法</td></tr><tr><td style="text-align:center"><code>#lists</code></td><td style="text-align:left">用来处理List集合的方法</td></tr><tr><td style="text-align:center"><code>#sets</code></td><td style="text-align:left">用来处理set集合的方法</td></tr><tr><td style="text-align:center"><code>#maps</code></td><td style="text-align:left">用来处理map集合的方法</td></tr></tbody></table><ul><li>举例</li></ul><p>我们在环境变量中添加日期类型对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"show3"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show3</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"today"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"show3"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面中处理</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  今天是: <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(today,'yyyy-MM-dd')&#125;"</span>&gt;</span>2018-04-25<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://img-blog.csdnimg.cn/20191119180654968.png" alt="在这里插入图片描述"></p><h3 id="4-4-字面值">4.4 字面值</h3><p>有的时候，我们需要在指令中填写基本类型如：字符串、数值、布尔等，并不希望被Thymeleaf解析为变量，这个时候称为字面值。</p><ul><li><p>字符串字面值</p><p>使用一对<code>'</code>引用的内容就是字符串字面值了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  你正在观看 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"'thymeleaf'"</span>&gt;</span>template<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 的字符串常量值.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>th:text</code>中的thymeleaf并不会被认为是变量，而是一个字符串</p><p><img src="https://img-blog.csdnimg.cn/20191119180722493.png" alt="在这里插入图片描述"></p></li><li><p>数字字面值</p><p>数字不需要任何特殊语法， 写的什么就是什么，而且可以直接进行算术运算</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>今年是 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"2018"</span>&gt;</span>1900<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>两年后将会是 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"2018 + 2"</span>&gt;</span>1902<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://img-blog.csdnimg.cn/20191119180740388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>布尔字面值</p><p>布尔类型的字面值是true或false：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    你填的是true</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里引用了一个<code>th:if</code>指令，跟vue中的<code>v-if</code>类似</p></li></ul><h3 id="4-5-拼接">4.5 拼接</h3><p>我们经常会用到普通字符串与表达式拼接的情况：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"'欢迎您:' + $&#123;user.name&#125; + '!'"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>字符串字面值需要用<code>''</code>，拼接起来非常麻烦，Thymeleaf对此进行了简化，使用一对<code>|</code>即可：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"|欢迎您:$&#123;user.name&#125;|"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与上面是完全等效的，这样就省去了字符串字面值的书写。</p><p><img src="https://img-blog.csdnimg.cn/20191119180817614.png" alt="在这里插入图片描述"></p><h3 id="4-6-运算">4.6 运算</h3><p>需要注意：<code>${}</code>内部的是通过OGNL表达式引擎解析的，外部的才是通过Thymeleaf的引擎解析，因此运算符尽量放在<code>${}</code>外进行。</p><ul><li><p>算术运算</p><p>支持的算术运算符：<code>+ - * / %</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;%2 == 0"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191119180834876.png" alt="在这里插入图片描述"></p></li><li><p>比较运算</p><p>支持的比较运算：<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code> ，但是<code>&gt;</code>, <code>&lt;</code>不能直接使用，因为xml会解析为标签，要使用别名。</p><p>注意 <code>==</code> and <code>!=</code>不仅可以比较数值，类似于equals的功能。</p><p>可以使用的别名：<code>gt (&gt;), lt (&lt;), ge (&gt;=), le (&lt;=), not (!). Also eq (==), neq/ne (!=).</code></p></li><li><p>条件运算</p><ul><li>三元运算</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.sex&#125; ? '男':'女'"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>三元运算符的三个部分：conditon ? then : else</p><p>​	condition：条件</p><p>​	then：条件成立的结果</p><p>​	else：不成立的结果</p><p>其中的每一个部分都可以是Thymeleaf中的任意表达式。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20191119180858546.png" alt="在这里插入图片描述"></p><ul><li><p>默认值</p><p>有的时候，我们取一个值可能为空，这个时候需要做非空判断，可以使用 <code>表达式 ?: 默认值</code>简写：</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125; ?: '二狗'"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当前面的表达式值为null时，就会使用后面的默认值。</p><p>注意：<code>?:</code>之间没有空格。</p><p><img src="https://img-blog.csdnimg.cn/20191119180922239.png" alt="在这里插入图片描述"></p><h3 id="4-7-循环">4.7 循环</h3><p>循环也是非常频繁使用的需求，我们使用<code>th:each</code>指令来完成：</p><p>假如有用户的集合：users在Context中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;users&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;"</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>${users} 是要遍历的集合，可以是以下类型：<ul><li>Iterable，实现了Iterable接口的类</li><li>Enumeration，枚举</li><li>Interator，迭代器</li><li>Map，遍历得到的是Map.Entry</li><li>Array，数组及其它一切符合数组结果的对象</li></ul></li></ul><p>在迭代的同时，我们也可以获取迭代的状态对象：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user,stat : $&#123;users&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;"</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>stat对象包含以下属性：</p><ul><li>index，从0开始的角标</li><li>count，元素的个数，从1开始</li><li>size，总元素个数</li><li>current，当前遍历到的元素</li><li>even/odd，返回是否为奇偶，boolean值</li><li>first/last，返回是否为第一或最后，boolean值</li></ul><h3 id="4-8-逻辑判断">4.8 逻辑判断</h3><p>有了<code>if和else</code>，我们能实现一切功能^_^。</p><p>Thymeleaf中使用<code>th:if</code> 或者 <code>th:unless</code> ，两者的意思恰好相反。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;user.age&#125; &lt; 24"</span>&gt;</span>小鲜肉<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果表达式的值为true，则标签会渲染到页面，否则不进行渲染。</p><p>以下情况被认定为true：</p><ul><li>表达式值为true</li><li>表达式值为非0数值</li><li>表达式值为非0字符</li><li>表达式值为字符串，但不是<code>&quot;false&quot;</code>,<code>&quot;no&quot;</code>,<code>&quot;off&quot;</code></li><li>表达式不是布尔、字符串、数字、字符中的任何一种</li></ul><p>其它情况包括null都被认定为false</p><p><img src="https://img-blog.csdnimg.cn/20191119180941530.png" alt="在这里插入图片描述"></p><h3 id="4-9-分支控制switch">4.9 分支控制switch</h3><p>这里要使用两个指令：<code>th:switch</code> 和 <code>th:case</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">"$&#123;user.role&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"'admin'"</span>&gt;</span>用户是管理员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"'manager'"</span>&gt;</span>用户是经理<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"*"</span>&gt;</span>用户是别的玩意<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，一旦有一个th:case成立，其它的则不再判断。与java中的switch是一样的。</p><p>另外<code>th:case=&quot;*&quot;</code>表示默认，放最后。</p><p><img src="https://img-blog.csdnimg.cn/20191119181004333.png" alt="在这里插入图片描述"></p><p>页面：</p><p><img src="https://img-blog.csdnimg.cn/20191119181217241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-10-JS模板">4.10.JS模板</h3><p>模板引擎不仅可以渲染html，也可以对JS中的进行预处理。而且为了在纯静态环境下可以运行，其Thymeleaf代码可以被注释起来：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:inline</span>=<span class="string">"javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> user = <span class="comment">/*[[$&#123;user&#125;]]*/</span> &#123;&#125;;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> age = <span class="comment">/*[[$&#123;user.age&#125;]]*/</span> <span class="number">20</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(user);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(age)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在script标签中通过<code>th:inline=&quot;javascript&quot;</code>来声明这是要特殊处理的js脚本</p></li><li><p>语法结构：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="comment">/*[[Thymeleaf表达式]]*/</span> <span class="string">"静态环境下的默认值"</span>;</span><br></pre></td></tr></table></figure><p>因为Thymeleaf被注释起来，因此即便是静态环境下， js代码也不会报错，而是采用表达式后面跟着的默认值。</p></li></ul><p>看看页面的源码：</p><p><img src="https://img-blog.csdnimg.cn/20191119181548659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们的User对象被直接处理为json格式了，非常方便。</p><p>控制台：</p><p><img src="https://img-blog.csdnimg.cn/20191119181627200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网页静态化技术</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot整合JWT实现用户认证</title>
    <url>/blog/posts/1993665256/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:51 GMT+0800 (GMT+08:00) --><h2 id="JWT实现用户认证">JWT实现用户认证</h2><blockquote><p>在介绍完JWT之后我们使用springboot整合JWT实现用户认证。</p></blockquote><ul><li><a href="https://blog.csdn.net/ZhouXianBiao/article/details/103256092" target="_blank" rel="noopener">前后端分离使用JWT做用户认证（概述）</a></li><li></li></ul><h3 id="JWT实现认证的原理">JWT实现认证的原理</h3><hr><div class="spoiler collapsed"><div class="spoiler-title">原理</div><div class="spoiler-content"><p>​服务器在生成一个JWT之后会将这个JWT会以Authorization : Bearer JWT 键值对的形式存放在	cookies里面发送到客户端机器，在客户端再次访问收到JWT保护的资源URL链接的时候，服务器会获取到cookies中存放的JWT信息，首先将Header进行反编码获取到加密的算法，在通过存放在服务器上的密匙对Header.Payload 这个字符串进行加密，比对JWT中的Signature和实际加密出来的结果是否一致，如果一致那么说明该JWT是合法有效的，认证成功，否则认证失败。</p></div></div><hr><a id="more"></a><!-- more --><h2 id="JWT实现用户认证的流程图">JWT实现用户认证的流程图</h2><p><img src="https://img-blog.csdnimg.cn/20191126145155598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="JWT的代码实现">JWT的代码实现</h2><h5 id="代码说明：">代码说明：</h5><p>代码中与JWT有关的内容如下</p><ol><li>config包中MvcConfig类配置生成一个JWT并配置了JWT拦截的URL，JwtProperties用于从配置文件中读取数据</li><li>web包中UserController用于处理用户的登录，校验时生成JWT</li><li>utils包中JwtUtils 用于对JWT的加密解析，RsaUtils用于从文件中读取公私钥</li><li>interceptor包中LoginInterceptor实现对登录的拦截认证</li><li>constants包中对JWT加密时要包含的内容</li></ol><p>其余的是属于对数据库访问的相关内容，以及异常提示内容和捕捉异常信息内容。(在下面贴出代码)</p><p><img src="https://img-blog.csdnimg.cn/20191126145218371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>引入关键依赖<code>pom.xml</code></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;commons-codec&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><code>application.yml文件</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/demo?useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    username: root</span><br><span class="line">    password: sasa</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    show-sql: <span class="keyword">true</span></span><br><span class="line">jwt:</span><br><span class="line">  secret: demo@Login(Auth&#125;*^31)&amp;demo% # 登录校验的密钥</span><br><span class="line">  pubKeyPath: D:/coding/rsa/rsa.pub # 公钥地址</span><br><span class="line">  priKeyPath: D:/coding/rsa/rsa.pri # 私钥地址</span><br><span class="line">  expire: 30 # 过期时间,单位分钟</span><br><span class="line">  cookieName: DB_TOKEN</span><br></pre></td></tr></table></figure><h6 id="JwtUtils类-加密解密token封装的方法">JwtUtils类 <code>加密解密token封装的方法</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.ssodemo.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.constants.JwtConstans;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.constants.UserInfo;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jws;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo      载荷中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey    私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireMinutes 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateToken</span><span class="params">(UserInfo userInfo, PrivateKey privateKey, <span class="keyword">int</span> expireMinutes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">//JWT_KEY_ID为写入token中用户id</span></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .claim(JwtConstans.JWT_KEY_ID, userInfo.getId())</span><br><span class="line">                .claim(JwtConstans.JWT_KEY_USER_NAME, userInfo.getUsername())</span><br><span class="line">                .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.RS256, privateKey)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo      载荷中的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey    私钥字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireMinutes 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateToken</span><span class="params">(UserInfo userInfo, <span class="keyword">byte</span>[] privateKey, <span class="keyword">int</span> expireMinutes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .claim(JwtConstans.JWT_KEY_ID, userInfo.getId())</span><br><span class="line">                .claim(JwtConstans.JWT_KEY_USER_NAME, userInfo.getUsername())</span><br><span class="line">                .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.RS256, RsaUtils.getPrivateKey(privateKey))</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥解析token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title">parserToken</span><span class="params">(String token, PublicKey publicKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥解析token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title">parserToken</span><span class="params">(String token, <span class="keyword">byte</span>[] publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(RsaUtils.getPublicKey(publicKey))</span><br><span class="line">                .parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title">getInfoFromToken</span><span class="params">(String token, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(token, publicKey);</span><br><span class="line">        Claims body = claimsJws.getBody();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserInfo(</span><br><span class="line">                ObjectUtils.toLong(body.get(JwtConstans.JWT_KEY_ID)),</span><br><span class="line">                ObjectUtils.toString(body.get(JwtConstans.JWT_KEY_USER_NAME))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的用户信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     用户请求中的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title">getInfoFromToken</span><span class="params">(String token, <span class="keyword">byte</span>[] publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(token, publicKey);</span><br><span class="line">        Claims body = claimsJws.getBody();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserInfo(</span><br><span class="line">                ObjectUtils.toLong(body.get(JwtConstans.JWT_KEY_ID)),</span><br><span class="line">                ObjectUtils.toString(body.get(JwtConstans.JWT_KEY_USER_NAME))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="RsaUtils工具类">RsaUtils工具类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.ssodemo.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 公钥保存路径，相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPublicKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 私钥保存路径，相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 私钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPrivateKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 公钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        X509EncodedKeySpec spec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePublic(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 私钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PKCS8EncodedKeySpec spec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据密文，生成rsa公钥和私钥,并写入指定文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKeyFilename  公钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKeyFilename 私钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret             生成密钥的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchAlgorithmException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateKey</span><span class="params">(String publicKeyFilename, String privateKeyFilename, String secret)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(secret.getBytes());</span><br><span class="line">        keyPairGenerator.initialize(<span class="number">1024</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.genKeyPair();</span><br><span class="line">        <span class="comment">// 获取公钥并写出</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicKeyBytes = keyPair.getPublic().getEncoded();</span><br><span class="line">        writeFile(publicKeyFilename, publicKeyBytes);</span><br><span class="line">        <span class="comment">// 获取私钥并写出</span></span><br><span class="line">        <span class="keyword">byte</span>[] privateKeyBytes = keyPair.getPrivate().getEncoded();</span><br><span class="line">        writeFile(privateKeyFilename, privateKeyBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFile(String fileName) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.readAllBytes(<span class="keyword">new</span> File(fileName).toPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把二进制写入文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String destPath, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File dest = <span class="keyword">new</span> File(destPath);</span><br><span class="line">        <span class="keyword">if</span> (!dest.exists()) &#123;</span><br><span class="line">            dest.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Files.write(dest.toPath(), bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MvcConfig</strong>类，<code>配置要的拦截或放行的URL，配合LoginInterceptor一起使用</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.ssodemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.<span class="keyword">module</span>.SimpleModule;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ser.std.ToStringSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.StringHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">loginInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor(jwtProperties,stringRedisTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//配置放行的路径</span></span><br><span class="line">        List&lt;String&gt; excludePath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        excludePath.add(<span class="string">"/swagger-ui.html"</span>);</span><br><span class="line">        excludePath.add(<span class="string">"/swagger-resources/**"</span>);</span><br><span class="line">        excludePath.add(<span class="string">"/webjars/**"</span>);</span><br><span class="line">        excludePath.add(<span class="string">"/login/**"</span>);</span><br><span class="line">        excludePath.add(<span class="string">"/login"</span>);	<span class="comment">//需要测试，暂时放行</span></span><br><span class="line">        registry.addInterceptor(loginInterceptor())<span class="comment">//注册拦截器</span></span><br><span class="line">            	<span class="comment">//拦截所有</span></span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>).excludePathPatterns(excludePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MappingJackson2HttpMessageConverter jackson2HttpMessageConverter =</span><br><span class="line">                <span class="keyword">new</span> MappingJackson2HttpMessageConverter();</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        SimpleModule simpleModule = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">        simpleModule.addSerializer(BigInteger<span class="class">.<span class="keyword">class</span>, <span class="title">ToStringSerializer</span>.<span class="title">instance</span>)</span>;</span><br><span class="line">        simpleModule.addSerializer(Long<span class="class">.<span class="keyword">class</span>, <span class="title">ToStringSerializer</span>.<span class="title">instance</span>)</span>;</span><br><span class="line">        simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance);</span><br><span class="line">        objectMapper.registerModule(simpleModule);</span><br><span class="line">        jackson2HttpMessageConverter.setObjectMapper(objectMapper);</span><br><span class="line">        converters.add(jackson2HttpMessageConverter);</span><br><span class="line">        converters.add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="LoginInterceptor，登录拦截器，拦截请求，如token失效或没有登录直接拦截回去">LoginInterceptor，<code>登录拦截器，拦截请求，如token失效或没有登录直接拦截回去</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.ssodemo.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.constants.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.utils.CookieUtils;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 登录拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个线程域，存放登录用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserInfo&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginInterceptor</span><span class="params">(JwtProperties jwtProperties,StringRedisTemplate stringRedisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jwtProperties = jwtProperties;</span><br><span class="line">        <span class="keyword">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  在业务处理器处理请求之前被调用</span></span><br><span class="line"><span class="comment">     *  如果返回false</span></span><br><span class="line"><span class="comment">     *       则从当前的拦截器往回执行所有拦截器的afterCompletion(),再退出拦截器链</span></span><br><span class="line"><span class="comment">     *  如果返回true</span></span><br><span class="line"><span class="comment">     *       执行下一个拦截器，直到所有拦截器都执行完毕</span></span><br><span class="line"><span class="comment">     *       再执行被拦截的Controller</span></span><br><span class="line"><span class="comment">     *       然后进入拦截器链</span></span><br><span class="line"><span class="comment">     *       从最后一个拦截器往回执行所有的postHandle()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.查询token</span></span><br><span class="line">        String token = CookieUtils.getCookieValue(request,jwtProperties.getCookieName());</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//2.未登录，返回401</span></span><br><span class="line">            response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.有token，查询用户信息</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//4.解析成功，说明已经登录</span></span><br><span class="line">            UserInfo userInfo = JwtUtils.getInfoFromToken(token,jwtProperties.getPublicKey());</span><br><span class="line">            <span class="comment">//5.放入线程域</span></span><br><span class="line">            t1.set(userInfo);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//6.抛出异常，证明未登录，返回401</span></span><br><span class="line">            response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在业务处理器处理请求执行完成后，生成视图之前执行的动作</span></span><br><span class="line"><span class="comment">     * 可在modelAndView中加入数据，比如当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在DispatcherServlet完全处理完请求后被调用,可用于清理资源等</span></span><br><span class="line"><span class="comment">     * 当有拦截器抛出异常时,会从当前拦截器往回执行所有的拦截器的afterCompletion()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       t1.remove();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//返回用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title">getLoginUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t1.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="JwtProperties，用于从配置文件中读取数据">JwtProperties，<code>用于从配置文件中读取数据</code></h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.ssodemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.utils.RsaUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "jwt")</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.secret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String secret; <span class="comment">// 密钥</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.pubKeyPath&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String pubKeyPath;<span class="comment">// 公钥</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.priKeyPath&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String priKeyPath;<span class="comment">// 私钥</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.expire&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expire;<span class="comment">// token过期时间</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jwt.cookieName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String cookieName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象一旦实例化后，就应该读取公钥和私钥</span></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//构造函数执行完成后执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//公钥私钥不存在，先生成</span></span><br><span class="line">        File pubkeyPath = <span class="keyword">new</span> File(pubKeyPath);</span><br><span class="line">        File prikeyPath = <span class="keyword">new</span> File(priKeyPath);</span><br><span class="line">        <span class="keyword">if</span> (!pubkeyPath.exists() || !prikeyPath.exists()) &#123;</span><br><span class="line">            RsaUtils.generateKey(pubKeyPath, priKeyPath, secret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取公钥和私钥</span></span><br><span class="line">        <span class="keyword">this</span>.publicKey = RsaUtils.getPublicKey(pubKeyPath);</span><br><span class="line">        <span class="keyword">this</span>.privateKey = RsaUtils.getPrivateKey(priKeyPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>constants</strong>包下JwtConstans为加密token时需要写入的用户的基本信息，UserInfo用于解密后存放用户信息</p><p><code>JwtConstans</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtConstans</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JWT_KEY_ID = <span class="string">"id"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JWT_KEY_USER_NAME = <span class="string">"username"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserInfo</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要使用到的工具类和拦截器以完成，我们编写Controller，service来测试</p><h6 id="Controller">Controller</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.ssodemo.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.constants.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.enums.ExceptionEnum;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.exception.CustomException;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.utils.CookieUtils;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties prop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">login</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @RequestParam(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password,</span></span><br><span class="line"><span class="function">            HttpServletResponse response, HttpServletRequest request) </span>&#123;</span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        String token = userService.login(username, password);</span><br><span class="line">        CookieUtils.newBuilder(response).httpOnly().request(request)</span><br><span class="line">                .build(prop.getCookieName(), token);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.OK).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验用户登录状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"verify"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;UserInfo&gt; <span class="title">verify</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @CookieValue(<span class="string">"DB_TOKEN"</span>)</span> String token,</span></span><br><span class="line"><span class="function">            HttpServletResponse response, HttpServletRequest request</span></span><br><span class="line"><span class="function">    ) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//解析token</span></span><br><span class="line">            <span class="comment">//已经拦截解析，取值即可</span></span><br><span class="line"></span><br><span class="line">            UserInfo info = LoginInterceptor.getLoginUser();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//刷新token，重新生成token</span></span><br><span class="line">            String newToken = JwtUtils.generateToken(info, prop.getPrivateKey(), prop.getExpire());</span><br><span class="line">            <span class="comment">//写入token中</span></span><br><span class="line">            CookieUtils.newBuilder(response).httpOnly().request(request)</span><br><span class="line">                    .build(prop.getCookieName(),newToken);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//已登录，返回用户信息</span></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(info);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//token已过期，或者token无效</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(ExceptionEnum.UNAUTHORIZED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="UserServiceImpl-实现">UserServiceImpl 实现</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.ssodemo.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.config.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.constants.UserInfo;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.enums.ExceptionEnum;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.exception.CustomException;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.utils.CodecUtils;</span><br><span class="line"><span class="keyword">import</span> com.demo.ssodemo.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Example;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository goodsRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties prop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">queruUserByUsernameAndPassword</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询用户</span></span><br><span class="line">        User record = <span class="keyword">new</span> User();</span><br><span class="line">        record.setUsername(username);</span><br><span class="line">        Optional&lt;User&gt; user = goodsRepository.findOne(Example.of(record));</span><br><span class="line">        <span class="comment">//校验</span></span><br><span class="line">        <span class="keyword">if</span> (!user.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(ExceptionEnum.INVALID_USERNAME_PASSWORD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验密码</span></span><br><span class="line">        String pwd = CodecUtils.md5Hex(password, user.get().getSalt());</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.equals(user.get().getPassword(), pwd)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(ExceptionEnum.INVALID_USERNAME_PASSWORD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据用户名和密码查询</span></span><br><span class="line">            User user = queruUserByUsernameAndPassword(username, password);</span><br><span class="line">            <span class="comment">//判断user</span></span><br><span class="line">            <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(ExceptionEnum.INVALID_USERNAME_PASSWORD);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//jwtUtils生成jwt类型的token</span></span><br><span class="line">            <span class="comment">//生成token</span></span><br><span class="line">            String token = JwtUtils.generateToken(<span class="keyword">new</span> UserInfo(user.getId(), username), prop.getPrivateKey(), prop.getExpire());</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"[登陆中心] 用户名或密码有误,用户名称&#123;&#125;"</span>, username, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(ExceptionEnum.INVALID_USERNAME_PASSWORD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们在Postman工具中测试，可以看到成功写入cookie中，然后我们每次请求都会携带这个token，我们只需要拦截下来校验即可，就可以实现<code>单点登录</code>一样的效果。</p><p><img src="https://img-blog.csdnimg.cn/20191126145717283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们请求校验用户登录状态的方法，或请求我们网站其他页面时，看看我们的拦截器是否有效果，是否能成功解析出用户信息。</p><p><img src="https://img-blog.csdnimg.cn/20191126145723674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看到我们的请求已经被拦截，并且我们使用工具类获取到客户端携带的cookie中我们设置的token，并成功解析，放入线程域中，以便我们在校验用户状态的方法中获取用户信息，在获取信息后我们刷新一遍token并重新写入cookie中，最后返回用户信息。</p><p><img src="https://img-blog.csdnimg.cn/20191126145730413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191126145737397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="总结：">总结：</h4><p>​	在我们登录一个网站之后，下一次打开网页的时候可能显示的还是登录的状态，不需要再次进行登录操作，通过JWT就可以实现这样一个用户认证的功能。当然使用Session可以实现这个功能，但是使用Session的同时也会增加服务器的存储压力，而JWT是将存储的压力分布到各个客户端机器上，从而减轻服务器的压力。</p><p>​	其实业务系统代码非常简单，主要是用了一个拦截器，拦截 http 请求，提取出 token 向 sso 认证中心验证 token 是否有效，有效放行，否则返回错误给前端。</p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>第三方技术</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>年终总结</title>
    <url>/blog/posts/521709994/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><h2 id="年终总结">年终总结</h2><p><strong>2019年最后一篇博客。</strong></p><p><code>总结就一句话，祝您来年不管生活还是工作都越来越顺利。</code></p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>最近问到的面试题</title>
    <url>/blog/posts/667971766/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><h2 id="面试题整理">面试题整理</h2><h5 id="拦截器跟监听器的执行顺序-两遍">拦截器跟监听器的执行顺序(两遍)</h5><div class="spoiler collapsed"><div class="spoiler-title">隐藏内容的标题</div><div class="spoiler-content"><p>首先执行监听器，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁的，之后执行过滤器，主要的用途是过滤字符编码、做一些业务逻辑判断等，之后再执行拦截器，拦截器的配置一般在SpringMVC的配置文件中，实现上基于<strong>java反射机制</strong>，属于面向切面编程（AOP）的一种应用</p><p>监听器 &gt; 过滤器 &gt; 拦截器</p></div></div><h5 id="1-spring跟springboot都什么区别">1.spring跟springboot都什么区别</h5><p>Spring是一个开源框架，主要是为了解决企业开发的复杂性而创建的，给开发java应用程序提供了很多基础架构的支持，它包含了一些很好的功能，比如依赖注入和开箱即用的模块，比如Springmvc，Spring JDBC等，提高了我们的开发效率。</p><p>spring boot的话它设计目的是用来简化Spring应用的初始搭建以及开发过程，基本上是spring框架的扩展，它不需要设置spring所需要的xml配置了，提高了我们的开发效率，还内嵌了tomcat等一些容器，可以直接跑起来，不需要做部署了，这就是我理解的它们之间的区别，谢谢。</p><p>（上面是结合自己的语言说的，下面贴上图片，要补充的还可以补充，<a href="https://blog.csdn.net/a909422229/article/details/82661286%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/a909422229/article/details/82661286）</a></p><p><img src="http://qaghauodb.bkt.clouddn.com/Bolg1588776308392-1588871418158.png" alt></p><h5 id="2-什么是AOP，项目中哪些地方用到了AOP">2.什么是AOP，项目中哪些地方用到了AOP</h5><p>AOP就是面向切面编程，它可以让我们在不修改之前业务逻辑的基础上可以动态的增加功能，从而使我们业务逻辑各部分耦合度降低，同时还提高了我们的开发效率，</p><p>（哪儿用到了就需要自己想项目中哪用到了，可以说用来做日志，安全或异常处理功能。）</p><h5 id="3-AOP的底层实现是什么">3.AOP的底层实现是什么</h5><p>AOP的底层实现是通过动态代理来实现(分别是jdk动态代理和cglib动态代理)</p><h5 id="4-动态代理是什么">4.动态代理是什么</h5><p>动态代理，就是为一个对象提供一种代理来控制对这个对象的访问，在某些情况下，客户不想或者不能直接引用另一个对象，这时候代理对象可以在客户端和目标对象之间起到中介的作用。</p><p><strong>其实就是当前对象不愿意做的事情，委托给别的对象做</strong>。 <a href="https://zhuanlan.zhihu.com/p/65501610" target="_blank" rel="noopener">不了解还可以看看</a></p><h5 id="5-mybatis的dao层跟mapper是怎么映射的，是谁映射谁">5.mybatis的dao层跟mapper是怎么映射的，是谁映射谁</h5><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。<br>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement</p><h5 id="7-mybaits如何实现动态链接">7.mybaits如何实现动态链接</h5><p>我们可以使用mybatis提供的标签来实现动态链接SQL，比如说if标签，在test中写判断语句，它特点就是只要成立就拼接在Sql语句中，如果都成立就全部都拼接，还有where标签会自动的给Sql语句添加where关键字，并将第一个and去除，这两个我们一般配合使用</p><h5 id="8-OOM说一下？">8.OOM说一下？</h5><p>oom意思就是说，当jvm没有足够的内存来给对象分配空间了，并且垃圾回收器也没有垃圾可以回收的时候就会抛出这个错误。</p><h5 id="JVM如何调优">JVM如何调优</h5><p>jvm参数设置，根据机器性能为程序运行分配合理区大小，比如设定堆内存大小，还有很多总结后更改</p><h5 id="9-maven如何在不同的环境打包不同的jar包">9.maven如何在不同的环境打包不同的jar包</h5><p>我们在打包的时候可以在pom.xml中添加profile配置，区分环境，通过profile可以指定多个环境，比如本机环境(<strong>local</strong>)、(开发小组内自测的)开发环境(<strong>dev</strong>)、(提供给测试团队的)测试环境(<strong>test</strong>)、预发布环境(<strong>pre</strong>)、正式生产环境(<strong>prod</strong>)，</p><p>每个环境可以定制化的配置，达到在不改动代码的情况下可以很方便的切换环境。</p><h5 id="10-项目中遇到的技术难点">10.项目中遇到的技术难点</h5><p>项目不同</p><h5 id="11-StringBuffer和StringBuilder有什么区别">11.StringBuffer和StringBuilder有什么区别</h5><p>首先他们的第一个区别就是StringBuffer是线程安全的，StringBuilder是线程不安全的，因为StringBuffer所有的公开方法都是由synchronized修饰的，而StringBuilder没有修饰，不过既然StringBuffer是线程安全的性能的话是有所下降的，所以在性能方面StringBuilder 的性能远大于StringBuffer。</p><p>所以StringBuffer 适用于用在多线程操作同一个 StringBuffer 的场景，如果是单线程场合 StringBuilder 更适合。</p><h5 id="12-如何实现多线程">12.如何实现多线程</h5><p>实现多线程有四种方式</p><p>1.继承Thread类，重写run方法，每次创建一个新的线程，都要新建一个Thread子类的对象</p><p>2.实现Runnable接口，不论创建多少个线程，只需要创建一个Runnable接口实现类的对象</p><p>3.实现Callable接口</p><p>4.线程池</p><p>什么是多线程</p><h5 id="13-索引的建立">13.索引的建立</h5><p>对id建立主键索引，对唯一字段建立唯一索引， 经常与其他表进行连接的表，在连接字段上应该建立索引，建立在选择性高的字段上，索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引</p><h5 id="14-说一下redis缓存雪崩和缓存穿透，缓存击穿">14.说一下redis缓存雪崩和缓存穿透，缓存击穿</h5><h5 id="什么是缓存雪崩？什么原因下会导致缓存雪崩">什么是缓存雪崩？什么原因下会导致缓存雪崩</h5><p>缓存雪崩一般是短期内大面积缓存失效，后面的请求都会去请求数据库，导致数据库瞬间压力增大，才会导致缓存雪崩。</p><p><strong>解决方案</strong>：</p><p>事前尽量保证整个redis集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略</p><p>事中使用hystrix限流&amp;降级，避免MySQL崩掉</p><p>之后利用redis的持久化机制保存的数据尽快恢复缓存</p><h5 id="什么是缓存穿透？">什么是缓存穿透？</h5><p>缓存穿透就是大量的请求去请求根本不存在于缓存中的key，导致请求直接到了数据库上，根本没有经过缓存这一层，</p><p><strong>解决方案</strong>：首先做好参数的校验，不合法的参数请求直接抛出异常信息给客户端</p><h5 id="什么是缓存击穿？">什么是缓存击穿？</h5><p>缓存击穿是指缓存中一个存在的key，在缓存过期的时候，同时又大量的请求，这些请求都会直接请求数据库，造成数据库过大压力</p><p>**解决方案：**1.设置热点数据永不过期，2.在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p><h5 id="15-和-的区别是什么？">15.#{} 和 ${} 的区别是什么？</h5><ol><li>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。$将传入的数据直接显示生成在sql中。</li><li>#方式能够很大程度防止sql注入，提高系统安全性，$方式无法防止Sql注入。</li><li>mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li>Mybatis在处理 ${} 时，就是把${}替换成变量的值，直接进行sql拼接，在处理#的时候会替换为?号，调用PreparedStatement的set方法来赋值</li></ol><h5 id="16-mysql分页的几种方式">16.mysql分页的几种方式</h5><p>1.直接使用数据库提供的SQL语句，全表扫描，速度慢</p><p>2.建立主键或唯一索引, 利用索引，索引扫描，速度快</p><p>3.利用order操作可以利用索引快速定位数据，避免全表扫描，速度快</p><h5 id="17-git常用命令">17.git常用命令</h5><p>pull拉取代码，push推送代码，commit提交代码到仓库 branch建立分支</p><h5 id="18-springboot跟平常搭建springmvc项目又什么区别，Spring-Boot与Spring的区别？">18.springboot跟平常搭建springmvc项目又什么区别，Spring Boot与Spring的区别？</h5><p>springboot它主要是为了解决使用Spring框架需要进行大量的配置太麻烦的问题，实现了自动配置，嵌入了Tomcat这样的web服务器，降低了项目搭建的复杂度，</p><p>Spring MVC它是Spring的一个模块，是基于Spring的一个 MVC 框架，在之前使用springmvc开发时我们还需要使用到像tomcat这服务器启动，而springboot内置服务器容器，我们只需要启动即可</p><p>换句话说就是换用Spring Boot以后，项目初始化方法变了，配置文件变了，另外就是不需要单独安装Tomcat这类容器服务器了，maven打出jar包直接跑起来就是个网站，但你最核心的业务逻辑实现与业务流程实现没有任何变化。</p><h5 id="19-谈谈spring的理解">19.谈谈spring的理解</h5><p>我对spring的理解就是，spring是一个轻量级的框架，它最核心的概念就是ioc跟aop，aop是指面向切面编程，比如在我们不修改原代码逻辑的情况下给程序统一添加新的功能的一种技术，比如记录日志，事物，安全这些，ioc控制反转，它是一种编程思想，用来实现模块间的解耦，在spring中它作用就是对对象的创建，维护，销毁等生命周期的控制，实现控制反转，另外spring还集成了各种优秀的框架，低侵入式设计也可以使程序代码对框架的依赖最小化，这就是我对spring的理解，谢谢</p><h5 id="20-error和exception有什么区别">20.error和exception有什么区别</h5><p>error是java程序运行中出现不可预料的异常情况，这种异常发生以后，会导致JVM处理不了或者不可恢复的情况</p><p>Exception是java程序运行中可预料的异常情况，我们可以获取到这种异常，并且对这种异常进行处理。</p><h5 id="21-什么是springcloud？">21.什么是springcloud？</h5><p>spring cloud是一种分布式服务的框架，它是微服务这种思想在Java领域的具体落地，它为我们开发人员提供了快速构建分布式系统的一些工具，比如说服务发现（Eureka）、断路器（Hystrix）、服务网关（Zuul）、客户端负载均衡（Ribbon）、服务跟踪（Sleuth）等等，spring cloud为这些提供了一阵套完整的解决方案。</p><h5 id="为什么需要SpringCloud？">为什么需要SpringCloud？</h5><p>微服务的角度而言就是把我们一个大的项目分解成多个小的模块，这些小的模块组合起来，完成功能。</p><p>而拆分出多个模块以后，就会出现各种各样的问题，而Spring Cloud提供了一整套的解决方案。</p><h5 id="什么是分布式和微服务">什么是分布式和微服务</h5><p>简单的说，微服务是架构设计方式，分布式是系统部署方式，两者概念不同</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">微服务：简单来说微服务就是很小的服务，小到一个服务只对应一个单一的功能，只做一件事。这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">分布式：分布式就是服务是分散部署在不同的机器上的，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的。逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</span><br></pre></td></tr></table></figure><h5 id="22-MySQL-存储过程">22.MySQL 存储过程</h5><p>存储过程是一种在数据库中存储的复杂程序，是为了完成特点功能的SQL语句集。</p><p>优点，存储过程可以封装，并隐藏复杂的商业逻辑，可以回传值，并可以接受参数</p><h5 id="23-从服务器读取文件和下载流程">23.从服务器读取文件和下载流程</h5><p>首先获取文件的名称、后缀，和文件在服务器的路径，根据文件在服务器的路径读取该文件转化为inputStream流，之后设置文件contentType类型，设置文件头，再写入输出流中</p><h5 id="24-异常处理可以怎么做">24.异常处理可以怎么做</h5><p>使用try块存放可能出现异常的java语句，catch用来捕获发生的异常，并对异常进行处理。Finally块用来清除程序中未释放的资源，,throw抛出异常 ,throws 异常声明</p><ol start="25"><li><h5 id="如何手动部署tomcat">如何手动部署tomcat</h5></li></ol><p>在server.xml中host节点下添加Context的内容，就可以不更改原项目路径而达到手动部署，</p><p>第二个是把项目打包成war包放进webapps中</p><h5 id="26-如何去掉字符串中间的空格">26.如何去掉字符串中间的空格</h5><p>可以使用字符串replaceAll方法去掉中间，首尾空格，StringUtils中使用replaceBlank去掉空格</p><h5 id="27-如何判断List-String-list中是否包含某个字符串呢">27.如何判断List<string>list中是否包含某个字符串呢?</string></h5><p>可以使用contains来判断是否包含某一个字符串</p><h5 id="28-list如何去重，实现的方式">28.list如何去重，实现的方式</h5><p>1.循环list中的所有元素然后删除重复，首先整两个循环在用if判断两个元素是否相等，相同就移除</p><p>2.通过HashSet剔除重复元素，利用了Set的特性：元素不可重复，其底层原理是先计算每个对象的hash值，再比较元素值是否相同，如果相同，则保留最新的。</p><p>3.利用set集合特性保持顺序一致去重，通过LinkedHashSet</p><p>3.使用java8新特性stream进行List去重</p><h5 id="29-前端防止按钮多次点击">29.前端防止按钮多次点击</h5><p>可以设置表单元素disabled 不让点击</p><p>可以用setTimeout函数设置多长让点击的时间</p><h5 id="30-java截取字符串">30.java截取字符串</h5><p>1.通过split()，不过通过这种方式截取会有很大的性能损耗，因为分析正则非常耗时。</p><p>2.通过subString()方法来进行字符串截取</p><h5 id="31-mysql常用的链接">31.mysql常用的链接</h5><p>左连接（把左边表的内容全部查出,右边表只查出满足条件的记录）</p><p>右连接（把右边表的内容全部查出,左边表只查出满足条件的记录）</p><p>内连接（查询两张表的共有部分），</p><p>全连接（查询两个表的全部信息）</p><h5 id="32-sql的常用的函数">32.sql的常用的函数</h5><p>聚合函数，avg，count，max，min，sun，</p><p>now 获取当前时间</p><p>DATE_FORMAT(date,fmt) 依照字符串fmt格式化日期date值</p><h5 id="33-怎么把sql字符串转换为日期类型">33.怎么把sql字符串转换为日期类型</h5><p>可以使用convert函数转换</p><h5 id="34-springmvc实现文件上传的两种方式">34.springmvc实现文件上传的两种方式</h5><p>首先在spring中配置上传解析器，之后再控制器方法通过MultipartFile获取整个上传的文件，获取文件的上传路径，文件原始名称，之后进行文件上传</p><h5 id="36-java-enum枚举使用场景及优缺点">36.java enum枚举使用场景及优缺点</h5><p>提高代码维护性，确保变量合法。提高代码可读性。不会经常修改的时候，就可以考虑用枚举，列如性别有男，女就可以用枚举来实现，一方面代码较优雅，另外线程安全</p><h5 id="37-redis什么场景下使用到。">37.redis什么场景下使用到。</h5><p>比如说缓存一些较为热点的数据，访问量较高的数据我们可以使用redis。</p><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h5 id="38-hashmap为什么是线程不安全的">38.hashmap为什么是线程不安全的</h5><p>在JDK1.7的时候就是在hashMap的进行put的时候，插入的元素超过了容量的范围，就会触发扩容操作，这个时候会采用头插法将原来的元素迁移到新的数组中，头插法会将链表的顺序翻转，在我们get的时候会出现死循环，所以HashMap是线程不安全的。</p><p><code>HashMap</code>的线程不安全主要体现在下面两个方面：</p><p>1.在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。<br>2.在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况。</p><h5 id="39-SQL优化的几种方式">39.SQL优化的几种方式</h5><h5 id="mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的">mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的</h5><p>​	1、避免 SELECT *，需要什么数据，就查询对应的字段。</p><p>​	2、利用自增主键索引、<code>order by</code>加<code>limit</code>，不使用offset</p><p>​	3、在性能要求比较高的场景中，杜绝查询中使用<code>临时表</code></p><p>​	4、使用 EXPLAIN 关键字分析SQL语句性能。</p><p>​	5、当只需要一条数据的时候，使用limit 1</p><p>1，对查询进行优化避免全表扫描，首先考虑where和group by上涉及的列进行建立索引</p><p>2，应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p><p>select id from t where num is null<br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>select id from t where num=0</p><p>3，应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，or，否则将引擎放弃使用索引而进行全表扫描</p><p>select id from t where num=10 or num=20<br>可以这样查询：<br>select id from t where num=10<br>union all<br>select id from t where num=20</p><p>4,in 和 not in 也要慎用，否则会导致全表扫描,连续值可以使用between and</p><p>select id from t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了：<br>select id from t where num between 1 and 3</p><p>5，查询使用模糊查询，两端使用%%，导致全表扫描</p><p>6，应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where num/2=100<br>应改为:<br>select id from t where num=100*2</p><p>7，应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where substring(name,1,3)=‘abc’–name以abc开头的id<br>应改为:<br>select id from t where name like ‘abc%’</p><p>8，不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引</p><p>9，在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，<br>否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>10，很多时候用 exists 代替 in 是一个好的选择</p><p>11，并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引</p><p>12，索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，<br>因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。<br>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>13，尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br>这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>14，尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，<br>其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>15，任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段</p><p>16，尽量避免大事务操作，提高系统并发能力。</p><p>17，尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>18，当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描</p><p>优化方式：用代码拼装sql时进行判断，没where加where，有where加and。</p><h5 id="40-mysql死锁是如何产生的。">40.mysql死锁是如何产生的。</h5><p>死锁的产生是指两个以上的进程在执行过程中，争夺资源造成的一种相互等待的现象，若是没有外力作用的话，它们都将无法推进下去，这个我们称之为死锁。</p><p>解决方案：表级锁不会产生死锁，所以解决死锁主要还是针对于最常用的InnoDB存储引擎。</p><h5 id="41-解决MySQL性能瓶颈">41.解决MySQL性能瓶颈</h5><h5 id="42-并发与并行的区别是什么？">42.并发与并行的区别是什么？</h5><p>并发是指多件事情，在同一时间段内同时发生，在多个任务之间是互相抢占资源的，其实看似是同时发生的事情，其实是互相交替执行的。</p><p>并行的话，在执行多个任务之间是不互相抢占资源的，只有在多CPU的情况下，才会发生并行</p><h5 id="43-oracle分页和mysql分页区别">43.oracle分页和mysql分页区别</h5><p>mysql使用的是limit进行分页</p><p>oracle使用ROWNUM关键字进行分页</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ROW_.*, <span class="keyword">ROWNUM</span> ROWNUM_</span><br><span class="line">          <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> *</span><br><span class="line">                  <span class="keyword">FROM</span> TABLE1</span><br><span class="line">                 <span class="keyword">WHERE</span> TABLE1_ID = XX</span><br><span class="line">                 <span class="keyword">ORDER</span> <span class="keyword">BY</span> GMT_CREATE <span class="keyword">DESC</span>) ROW_</span><br><span class="line">         <span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">20</span>)</span><br><span class="line"> <span class="keyword">WHERE</span> ROWNUM_ &gt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h5 id="44-ThreadLocal有了解过吗。">44.ThreadLocal有了解过吗。</h5><p>threadlocal它是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，因为在使用set 和 get 操作的都是对应线程的 table数组，因此在不同的线程中访问同一个 ThreadLocal 对象的 set 和 get 进行存取数据是不会相互干扰的。</p><h5 id="45-ThreadLocal和Synchronized区别">45.ThreadLocal和Synchronized区别</h5><p>ThreadLocal和Synchronized都是为了解决多线程中相同变量的访问冲突问题</p><p>不同的点是Synchronized是通过线程等待，牺牲时间来解决访问冲突</p><p>ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</p><h5 id="46-抽象类和接口都有什么区别？">46.抽象类和接口都有什么区别？</h5><p>首先他们两者的语法上抽象类是可以有构造方法，可以有普通成员变量，还可以包含一些非抽象的方法，接口中没有构造方法，也不能有普通成员变量，只能是公共的静态的常量，不可以有非抽象的普通方法，</p><p>抽象类可以实现代码的复用，如果你拥有一些方法并且想让它们中的一些有默认实现，那么就使用抽象类</p><p>如果说想实现多重继承，那就必须使用接口，因为java不支持多继承，但可以实现多个接口</p><p><img src="http://qaghauodb.bkt.clouddn.com/Bolg1870221-cc52092cc8b11d0a.webp" alt></p><h5 id="47-如何保证缓存-redis-与数据库-MySQL-的一致性">47.如何保证缓存(redis)与数据库(MySQL)的一致性</h5><p>我们可以采用先淘汰缓存，在写入数据库，在休眠1秒之后再次淘汰缓存，延迟双删策略来保证数据的一致性，不过这样增长了处理时间</p><p>我们还可以新增一个线下的读binlog的异步淘汰模块，读取到binlog中的数据，异步的淘汰缓存。 具体是使用阿里的Canal完成订阅binlog日志的功能</p><h5 id="48-java什么是反射机制">48.java什么是反射机制</h5><p>程序运行过程中动态的操作对象，对于任意一个类，都能够知道这个类的所有属性和方法，还能够调用它的任意属性和方法，这种动态获取信息我们称为反射机制</p><p>应用场景：经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。</p><h5 id="49-反射的具体实现">49.反射的具体实现</h5><p>想要实现反射，就必须先拿到这个类的字节码文件对象(.class)，通过字节码文件对象，就能够通过该类中的方法获取到我们想要的所有信息，每一个类对应着一个字节码文件也就对应着一个Class类型的对象，也就是字节码文件对象.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过Class 对象的forName()静态方法来获取Class对象。</span><br><span class="line"><span class="comment">//寻找该名称的类文件，加载进内存，并创建Class对象。</span></span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line"><span class="comment">//通过Class对象的newInstance()创建类对象。</span></span><br><span class="line">Object o = clazz.newInstance();</span><br></pre></td></tr></table></figure><h5 id="50-面向对象的三个基本特征">50.面向对象的三个基本特征</h5><p>封装、继承、多态。</p><p>封装：就是将属于一个抽象的方法属性特点等，封装到一个类里面，隐藏实现细节，对外提供访问</p><p>继承：它是程序中两个类之间的一种关系，它可以继承父类的所有功能，并且无需重新编写原来的类的情况，对这些功能进行扩展</p><p>多态：是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作，简单的说就是：<strong>允许将子类类型的指针赋值给父类类型的指针</strong></p><p>实现多态，有二种方式，覆盖，重载。</p><h5 id="51-spring的单例bean">51.spring的单例bean</h5><p>单例bean的优势就是减少了创建实例，然后可以快速获取到bean，因为单例的获取操作除了第一次生成外，其他的都是从缓存中获取</p><p>但是它有一个很大的劣势就是不能做到线程安全，所有的请求都共享一个bean实例</p><h5 id="52-方法重写和重载">52.方法重写和重载</h5><p>重写当子类需要修改父类的一些方法进行扩展，增大功能</p><p>重载就是指子类的方法和父类的方法有完全相同的返回值类型、方法名、参数个数以及参数类型，</p><h5 id="53-常见异常">53.常见异常</h5><p>系统异常，空指针异常找不到值，还有一些业务类的异常</p><h5 id="54-说一下-JVM-有哪些垃圾回收算法？">54.说一下 JVM 有哪些垃圾回收算法？</h5><ul><li>标记-清除算法：对存活的对象进行标记，清除没有标记的，也就是垃圾对象。缺点：效率不高，无法清除垃圾碎片。</li><li>标记-整理算法：对存活的对象进行标记，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><h5 id="55-什么是多线程？">55.<strong>什么是多线程？</strong></h5><p>多线程：是指从软件或者硬件上实现多个线程的并发技术。</p><p><strong>多线程的好处：</strong></p><ol><li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载</li><li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</li></ol><h2 id="Java集合类问题">Java集合类问题</h2><h5 id="56-为什么HashMap中String、Integer这样的包装类适合作为K？">56.为什么HashMap中String、Integer这样的包装类适合作为K？</h5><p>String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><h5 id="57-ConcurrentHashMap和Hashtable的区别？">57.ConcurrentHashMap和Hashtable的区别？</h5><p>ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h5 id="58-HashMap-和-ConcurrentHashMap-的区别？">58.HashMap 和 ConcurrentHashMap 的区别？</h5><p>HashMap是线程不安全的，当出现多线程操作时，会出现安全隐患。</p><p>ConcurrentHashMap是用的块锁，相当于是把院子里的有安全隐患的房间锁上了，这样一来，就不会让去其他房间办事的人等待了。</p><p>在1.8中ConcurrentHashMap，采用了数组+链表+红黑树的实现方式来设计</p><h5 id="58-ArrayList-和-Vector-的区别？">58.ArrayList 和 Vector 的区别？</h5><p>共同点：这两个类都实现了List接口，他们都是有序的集合，就是存储在这两个集合的元素位置都是有顺序的，相当于一种动态的数组</p><p>区别：</p><p>​	同步性</p><p>​ Vector 是线程安全的，在方法之间是线程同步的，如果有多个线程会访问到集合，那最好是使用 Vector， 因为不需要我们自己再去考虑和编写线程安全的代码</p><p>​ ArrayList 是线程不安全的，它的方法之间是线程不同步的，它不考虑线程安全的问题，所以效率会高一些</p><p>​	他们数据增长的形式也不相同</p><p>​ ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 (0.5 倍 + 1) 个空间。</p><p>​ Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 2 倍）</p><h5 id="59-数组和-ArrayList-有什么区别？">59.<strong>数组和 ArrayList 有什么区别？</strong></h5><ol><li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型，不过在使用元素的时候会有装箱和拆箱的操作,降低了程序的性能。</li><li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li><li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li></ol><h5 id="60-ArrayList和LinkedList的区别？">60.ArrayList和LinkedList的区别？</h5><p>区别：</p><p>​	ArrayList底层是使用数组实现的，通过索引下标可以快速的查到数据，所以它对数据的查询操作效率高的多</p><p>​	LinkedList底层使用双向链表实现的，所以它对于数据的增加删除操作效率较ArrayList要高</p><p>共同点：他们都不是线程安全的，并且数据都可以重复</p><h5 id="61-jdk1-7和jdk1-8的区别">61.jdk1.7和jdk1.8的区别</h5><p>比如说新增了<strong>Lambda 表达式</strong>，<strong>stream流</strong>，<strong>接口可以有默认实现</strong>，<strong>Switch语句支持String类型。</strong></p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>经典面试题整理</title>
    <url>/blog/posts/1591749067/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><h1>经典面试题整理</h1><h3 id="MyBatis面试题">MyBatis面试题</h3><h5 id="和-的区别是什么？">#{} 和 ${} 的区别是什么？</h5><ol><li><p>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。$将传入的数据直接显示生成在sql中。</p></li><li><p>#方式能够很大程度防止sql注入，提高系统安全性，$方式无法防止Sql注入。</p></li><li><p>mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p></li><li><p>Mybatis在处理 ${} 时，就是把${}替换成变量的值，直接进行sql拼接，在处理#的时候会替换为?号，调用PreparedStatement的set方法来赋值</p></li></ol><a id="more"></a><!-- more --><h5 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？">介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h5><p>1.一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>2.二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置</p><p>3.对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h5 id="介绍一下MyBatis的缓存？">介绍一下MyBatis的缓存？</h5><p>MyBatis将数据缓存设计成两级结构，分为一级缓存、二级缓存，在mybatis中一级缓存默认开始，二级缓存需要配置。</p><p>一级缓存是Session会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）</p><p>二级缓存是Application应用级别的缓存，它的是生命周期很长，跟Application的生命周期一样，也就是说它的作用范围是整个Application应用，mybatis的二级缓存是多个SqlSession共享，其作用域是mapper的同一个namespace，不同的sqlsession两次执行相同namespace下的sql语句，且向sql语句中传递的参数也相等，最终执行相同的sql语句，第一次执行完毕后会将从数据库查询到的数据写到缓存（内存）中，第二次会存缓存中获取数据而不再进行数据库查询，从而提高查询效率。</p><h5 id="MyBatis-执行批量插入有哪些方式？-优缺点是什么">MyBatis 执行批量插入有哪些方式？ 优缺点是什么?</h5><p>​	<strong>mybiats foreach标签</strong></p><p>​ foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。</p><p>​	<strong>mybatis ExecutorType.BATCH</strong></p><p>​ Mybatis内置的ExecutorType有3种，默认的是simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p><p>​	<strong>xml、注解两种方式的区别：</strong></p><ol><li>foreach相当语句逐条insert语句执行，将出现如下问题：<br>mapper接口的insert方法返回值将是最后一条insert语句的操作成功的记录数目（就是0或1），而不是所有insert语句的操作成功的总记录数目；<br>当其中一条不成功时，不会进行整体回滚。</li><li>注解方式：当有一条插入不成功时，会整体回滚。</li></ol><h5 id="当实体类中的属性名和表中的字段名不一样时有哪些处理方法？">当实体类中的属性名和表中的字段名不一样时有哪些处理方法？</h5><ul><li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li><li>通过来映射字段名和实体类属性名的一一对应的关系</li></ul><h5 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？">Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h5><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，</p><p>Mybatis提供了9种动态sql标签</p><p>​	<strong>trim | where | set | foreach | if | choose| when | otherwise | bind</strong></p><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h5 id="通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？">通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h5><ul><li>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。</li><li>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li><li>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</li></ul><h5 id="Mapper接口绑定有几种实现方式-分别是怎么实现的">Mapper接口绑定有几种实现方式,分别是怎么实现的?</h5><p>接口绑定有两种实现方式：<br>一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</p><p>另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</p><h5 id="在mybatis中如何获取自动生成的-主-键值">在mybatis中如何获取自动生成的(主)键值?</h5><p>insert 方法总是返回一个int值，这个值代表的是插入的行数。<br>通过属性usegeneratedkeys=”true”和keyproperty=”id”来获取生成的键值，自动生成的键值被传入的参数对象中。</p><p>useGeneratedKeys： 是否自动生成主键，默认false<br>keyProperty ：返回的主键值赋给哪个属性<br>keyColumn： 数据库中的自增主键的列名，默认是数据库表的第一列。当主键列不是表中的第一列的时候需要设置，PostgreSQL必须设置。<br>主键自动生成，取决于数据库是否支持自增主键。实际上当设置了useGeneratedKeys=“true”，Mybatis会调用JDBC的getGeneratedKeys方法，并将获取的主键值赋值给keyProperty 指定的属性。</p><h5 id="在-Mapper-中如何传递多个参数">在 Mapper 中如何传递多个参数?</h5><p>​	**第一种：DAO 层的函数：**对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二参数，更多参数一致往后加即可。</p><p>​	<strong>第二种： 使用 @param 注解：</strong><code>#{}</code>里面的名称对应的是注解<code>@Param</code>括号里面修饰的名称。</p><p>​	<strong>第三种：</strong> <strong>Map传参法：</strong><code>#{}</code>里面的名称对应的是<code>Map</code>里面的key名称。</p><p>​	<strong>第四种：Java Bean传参法：</strong><code>#{}</code>里面的名称对应的是<code>User</code>类里面的成员属性。</p><h5 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？">Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h5><p>​	Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor</p><p>​	SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。<br>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。<br>​	BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。<br>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内</p><h5 id="Mybatis是如何进行分页的？分页插件的原理是什么？">Mybatis是如何进行分页的？分页插件的原理是什么？</h5><blockquote><p>1.<strong>SQL 分页</strong>使用Map来进行包装数据实现分页功能</p><p>2.<strong>使用RowBounds来实现分页</strong>，Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>3.<strong>使用拦截器分页</strong>，通过自定义插件的形式实现分页，也是最好的，也叫做分页拦截器。</p></blockquote><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL，然后重写SQL，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h5 id="简述Mybatis的插件运行原理，以及如何编写一个插件">简述Mybatis的插件运行原理，以及如何编写一个插件</h5><p>​	Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>​	实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法并在配置文件中配置你编写的插件。</p><h5 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？">Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><p>​	第一种是使用<resultmap>标签，逐一定义数据库列名和对象属性名之间的映射关系。</resultmap></p><p>​	第二种是使用SQL列的别名功能，将列的别名书写为对象属性名。</p><p>​	有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h5 id="为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？">为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h5><p>Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具</p><p>1、全自动完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql，而半自动仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p><p>2、全自动数据库移植性远大于半自动</p><p>3、SQL直接优化上，半自动要比全自动方便很多</p><p>4、半自动后期维护比全自动更方便</p><p>5、 MyBatis的对象关系映射配置灵活，Hibernate则需要配置完整的对象关系映射，对象关系维护的更好。业务表的关联太多，建议使用MyBatis。</p><h5 id="MyBatis-实现一对一有几种方式-具体怎么操作的？">MyBatis 实现一对一有几种方式?具体怎么操作的？</h5><p>有联合查询和嵌套查询</p><p>​	联合查询是几个表联合查询，只查询一次,，通过在resultMap里面配置association节点配置一对一的类就可以完成。</p><p>​	嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，通过association配置，但另外一个表的查询通过select属性配置。</p><h5 id="MyBatis-实现一对多有几种方式-怎么操作的？">MyBatis 实现一对多有几种方式,怎么操作的？</h5><p>有联合查询和嵌套查询。</p><p>​	联合查询是几个表联合查询，只查询一次，通过在resultMap里面的collection节点配置一对多的类就可以完成。</p><p>​	嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，通过配置collection，但另外一个表的查询通过select节点配置。</p><h5 id="数据库链接中断如何处理？">数据库链接中断如何处理？</h5><p>数据库的访问底层是通过tcp实现的，当链接中断是程序是无法得知，导致程序一直会停顿一段时间在这，最终会导致用户体验不好。</p><p>connection操作底层是一个循环处理操作，因此可以进行时间有关的参数：</p><ul><li>max_idle_time ： 表明最大的空闲时间，超过这个时间socket就会关闭</li><li>connect_timeout ： 表明链接的超时时间</li></ul><blockquote><p>数据库服务器活的杠杠的，但是因为网络用塞，客户端仍然连不上服务器端，这个时候就要设置timeout，别一直傻等着</p></blockquote><h5 id="在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？">在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？</h5><blockquote><p>插入的过程一般都是分两步的：先判断是否存在记录，没有存在则插入否则不插入。如果存在并发操作，那么同时进行了第一步，然后大家都发现没有记录，然后都插入了数据从而造成数据的重复。</p><p>在分布式环境中通过Redis分布式锁解决即可，多线程环节下用普通的Lock锁解决即可</p></blockquote><h5 id="事务执行过程中宕机的应对处理方式">事务执行过程中宕机的应对处理方式</h5><p>可以依据事务日志进行回滚或者进行执行。</p><p>事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化 ，两种类型：</p><blockquote><p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。</p></blockquote><ul><li>redo log ：按语句的执行顺序，依次交替的记录在一起</li><li>undo log： 主要为事务的回滚服务。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</li></ul><h5 id="Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？">Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？</h5><p>​	Java客户端中的一个Connection<strong>不是</strong>在MySQL中就对应一个线程来处理这个链接，而是通过<strong>监听socket的主线程+线程池里面固定数目的工作线程来处理的。</strong></p><p>高性能服务器端开发底层主要靠I/O复用来处理，这种模式是：</p><blockquote><p><strong>单线程+事件处理机制</strong></p></blockquote><p>​	在MySQL有一个主线程，这是单线程，它不断的循环查看是否有socket是否有读写事件，如果有读写事件，再从线程池里面找个工作线程处理这个socket的读写事件，完事之后工作线程会回到线程池。</p><h3 id="Spring面试题">Spring面试题</h3><h5 id="spring-提供了哪些配置方式？">spring 提供了哪些配置方式？</h5><ul><li>基于 xml 配置<ul><li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。</li></ul></li><li>基于注解配置<ul><li>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。</li></ul></li><li>基于 Java API 配置<ul><li>Spring 的 Java 配置是通过使用@Bean 和 @Configuration 来实现。</li></ul></li></ul><h5 id="Spring-Framework-有哪些不同的功能？">Spring Framework 有哪些不同的功能？</h5><ul><li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li><li><strong>IOC</strong> - 控制反转</li><li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h5 id="解释一下什么是-aop？什么是IOC？">解释一下什么是 aop？什么是IOC？</h5><p>AOP ：面向切面编程，是面向对象开发的一种补充，也是Spring框架中的一个重要内容。它允许开发人员在不改变原来模型的以满足新的需求 ，例如，开发人员可以在不改变原来业务逻辑模型的基础可以进行动态的增加日志，安全或异常处理功能。从而使得业务逻辑各部分之间的耦合度降低，提供程序的可重用性，同时提高了开发的效率。</p><p>IOC ：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。</p><h5 id="什么是aop，aop的作用是什么-aop中的关键名词有些那些，相互关系是什么">什么是aop，aop的作用是什么?aop中的关键名词有些那些，相互关系是什么?</h5><p>​	AOP就是面向切面编程，它可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。</p><p>​	作用是让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。</p><h5 id="说下对IOC容器的理解以及IOC容器是怎么工作的？">说下对IOC容器的理解以及IOC容器是怎么工作的？</h5><p>说下对IOC容器的理解</p><ul><li>就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。</li></ul><p>IOC容器是怎么工作的？</p><ul><li>在配置文件中声明Bean定义也就是为Bean配置元数据，IOC容器的Bean Reader读取并解析配置文件，根据定义生成BeanDefinition配置元数据对象，IOC容器根据BeanDefinition进行实例化、配置及组装Bean。由客户端实例化容器，获取需要的Bean。</li></ul><h5 id="Spring中AOP-有哪些实现方式？">Spring中AOP 有哪些实现方式？</h5><ul><li>配置ProxyFactoryBean，显式地设置advisors, advice, target等</li><li>配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</li><li>通过&lt;aop: config&gt;来配置（纯POJO切面）</li><li>通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</li></ul><h5 id="简述-Spring-IoC-的实现机制？">简述 Spring IoC 的实现机制？</h5><p>​	<strong>spring ioc指的是控制反转，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。交由Spring容器统一进行管理，从而实现松耦合</strong>，<strong>“控制反转”，不是什么技术，而是一种设计思想。</strong></p><p>​	Spring IoC实现机制简单来说就是工厂模式加反射机制， 在spring初始化的时候 , 初始化所有bean , 然后在应用程序需要的时候 , 通过反射机制来获取</p><h5 id="Spring-Bean-在容器的生命周期是什么样的？简单的说一下spring的生命周期？">Spring Bean 在容器的生命周期是什么样的？简单的说一下spring的生命周期？</h5><p><img src="/blog/posts/1591749067/1586619066544.png" alt="1586619066544"></p><ol><li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li><li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li><li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li><li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li></ol><h5 id="Spring中的bean都有哪些作用域？">Spring中的bean都有哪些作用域？</h5><ul><li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li><li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li><li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li><li>session：同一个 Session 共享一个 bean 实例。</li><li>global-session：同 session 作用域不同的是，所有的Session共享一个Bean实例。</li></ul><h5 id="解释一下Spring-AOP里面的几个名词？">解释一下Spring AOP里面的几个名词？</h5><ul><li>切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</li><li>连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。</li><li>通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以<strong>拦截器</strong>做通知模型， 并维护一个以连接点为中心的拦截器链。</li><li>切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add*、search*。</li><li>引入（Introduction）：声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</li><li>目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</li><li>织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</li></ul><h5 id="aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理">aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理</h5><p>​	aop的底层实现？</p><p>​ AOP的核心机制通过动态代理来实现(jdk动态代理和cglib动态代理)</p><p>​	动态代理是如何动态？</p><p>​ 1.<strong>使用接口(动态代理)</strong></p><p>​ 如果被代理的对象是面向接口编程的,那么Spring直接使用实现这些接口,然后把需要插入的内容在这个接口上下文中插入</p><p>​ 2.<strong>使用继承(CGLIB)</strong></p><p>​ 如果被代理的对象没有基于接口编程,那么Spring会调用cglib库,通过子类继承的方式,动态插入需要的内容,并且调用父类的方法实现cglib内部拥有一个小的字节码处理框架asm,来转换字节码生成新的类.所以spring调用了cglib,相当于生成了一个被代理对象的子类,来取代被代理对象。</p><p>​	如何动态的为这100个对象代理？</p><p>​ ？</p><h5 id="简述一下Spring中的单例Bean的线程安全问题？">简述一下Spring中的单例Bean的线程安全问题？</h5><p>​	默认 spring 容器中的 bean 是单例的，当单例中存在竞态条件，即有线程安全问题，所以 spring 管理的 bean 的线程安全跟 bean 的创建作用域和 bean 所在的使用环境是否存在竞态条件有关，spring 并不能保证 bean 的线程安全。</p><h5 id="spring的bean配置的几种方式？">spring的bean配置的几种方式？</h5><p>​	基于XML的配置，基于注解的配置，基于Java类的配置三种方式。</p><h5 id="说说spring的监听器的实现原理？">说说spring的监听器的实现原理？</h5><p>​	首先写一个监听器（ApplicationListener实现类）来监听某个事件，原理：使用EventListenerMethodProcessor处理器来解析方法上的@EventListener，然后把监听器加入到容器，只要容器中有相关事件的发布，我们就能监听到这个事件</p><h5 id="spring-常用的注入方式有哪些？">spring 常用的注入方式有哪些？</h5><p>​	Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：构造方法注入，setter注入，基于注解的注入。</p><h5 id="spring-中的-bean-是线程安全的吗？支持几种-bean-的作用域？">spring 中的 bean 是线程安全的吗？支持几种 bean 的作用域？</h5><p>​	Spring 不保证 bean 的线程安全。默认 spring 容器中的 bean 是单例的，当单例中存在竞态条件，即有线程安全问题，所以 spring 管理的 bean 的线程安全跟 bean 的创建作用域和 bean 所在的使用环境是否存在竞态条件有关，spring 并不能保证 bean 的线程安全。</p><p>Spring支持如下5种作用域：</p><ul><li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li><li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li><li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li><li>session：同一个 Session 共享一个 bean 实例。</li><li>global-session：同 session 作用域不同的是，所有的Session共享一个Bean实例。</li></ul><h5 id="BeanFactory和ApplicationContext的区别是什么？">BeanFactory和ApplicationContext的区别是什么？</h5><p>​ BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p>区别：</p><ul><li>BeanFactroy采用的是延迟加载形式来注入Bean的，在使用到某个Bean时才对该Bean进行加载实例化，这样我们不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean，这样在容器启动时我们就可以发现Spring中存在的配置错误。</li><li>BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入。</li><li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li><li>beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。</li></ul><h5 id="Spring-Aop和AspecJ-Aop有什么区别？">Spring Aop和AspecJ Aop有什么区别？</h5><table><thead><tr><th style="text-align:left">Spring AOP</th><th style="text-align:left">AspectJ</th></tr></thead><tbody><tr><td style="text-align:left">在纯 Java 中实现</td><td style="text-align:left">使用 Java 编程语言的扩展实现</td></tr><tr><td style="text-align:left">不需要单独的编译过程</td><td style="text-align:left">除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</td></tr><tr><td style="text-align:left">只能使用运行时织入</td><td style="text-align:left">运行时织入不可用。支持编译时、编译后和加载时织入</td></tr><tr><td style="text-align:left">功能不强-仅支持方法级编织</td><td style="text-align:left">更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等…。</td></tr><tr><td style="text-align:left">只能在由 Spring 容器管理的 bean 上实现</td><td style="text-align:left">可以在所有域对象上实现</td></tr><tr><td style="text-align:left">仅支持方法执行切入点</td><td style="text-align:left">支持所有切入点</td></tr><tr><td style="text-align:left">代理是由目标对象创建的, 并且切面应用在这些代理上</td><td style="text-align:left">在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</td></tr><tr><td style="text-align:left">比 AspectJ 慢多了</td><td style="text-align:left">更好的性能</td></tr><tr><td style="text-align:left">易于学习和应用</td><td style="text-align:left">相对于 Spring AOP 来说更复杂</td></tr></tbody></table><h5 id="spring-JDBC-API-中存在哪些类？">spring JDBC API 中存在哪些类？</h5><ul><li>JdbcTemplate</li><li>SimpleJdbcTemplate</li><li>NamedParameterJdbcTemplate</li><li>SimpleJdbcInsert</li><li>SimpleJdbcCall</li></ul><h5 id="解释spring中不同方式的自动装配">解释spring中不同方式的自动装配</h5><p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p><ol><li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li><li>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li><li>byType:通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li><li>constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类	型，将会抛出异常。</li><li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ol><h5 id="ApplicationContext通常的实现是什么？">ApplicationContext通常的实现是什么？</h5><ul><li>FileSystemXmlApplicationContext：此容器从一个xml文件中加载beans的定义，XML Bean配置文件的全路径名必须提供给它的构造函数。</li><li>ClassPathXmlApplicationContext：此容器也从一个xml文件中加载beans的定义，这里你需要正确设置classpath，因为这个容器将在classpath里找bean配置。</li><li>WebXmlApplicationContext：此容器加载一个xml文件，次文件定义了一个web应用的所有bean。</li></ul><h5 id="什么是基于Java的Spring注解配置-给一些常见注解的例子">什么是基于Java的Spring注解配置? 给一些常见注解的例子</h5><p>​	基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Required 注解，这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p><h5 id="动态代理是什么？在spring中有哪些应用？">动态代理是什么？在spring中有哪些应用？</h5><p>动态代理，就是为一个对象提供一种代理来控制对这个对象的访问，在某些情况下，客户不想或者不能直接引用另一个对象，这时候代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>Spring中主要使用cglib和jdk动态代理，主要在SpringAop就是基于动态代理来实现的。</p><p>jdk动态代理主要使用场景是：被代理的对象有实现的接口</p><p>cglib代理主要使用场景是：被代理对象的是类而没有任何接口实现</p><h3 id="Spring关于事务面试题">Spring关于事务面试题</h3><h5 id="你使用过Spring的事务吗？是怎么用的？">你使用过Spring的事务吗？是怎么用的？</h5><p>使用过基于注解和基于xml配置的事务管理，注解是在业务方法上使用@Transaction注解，将事务规则应用到业务逻辑中。基于xml配置的事物管理是在applicationContext.xml进行配置就可以了</p><h5 id="简述一下Spring中的事务的实现方式？">简述一下Spring中的事务的实现方式？</h5><ul><li>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li><li>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。声明式事务管理又有两种实现方式：基于xml配置文件的方式；另一个实在业务方法上进行@Transaction注解，将事务规则应用到业务逻辑中</li></ul><h5 id="在spring中有几种事务管理，分别是什么">在spring中有几种事务管理，分别是什么?</h5><p>​	Spring有两种事务管理方式：</p><p>​ 1、编程式：比较灵活，但是代码量大，存在重复的代码比较多，我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法</p><p>​ 2、声明式：声明式事务管理比编程式更灵活方便，声明式事务管理有两种形式：①配置文件 ②在业务方法上加上@Transaction注解，将事务规则应用到业务逻辑中。</p><h5 id="什么是spring-的事务隔离？Spring的事务有哪几种隔离级别-spring-事务实现方式有哪些？">什么是spring 的事务隔离？Spring的事务有哪几种隔离级别? spring 事务实现方式有哪些？</h5><p>spring事务的隔离级别</p><ul><li>Default：使用数据库默认的事务隔离级别</li><li>未提交读：允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读</li><li>已提交读：允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生</li><li>可重复读 ：对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生</li><li>串行化的：完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。</li></ul><p>spring实现事务的方式：</p><ul><li>编程式事务管理：需要手动编写代码，我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法</li><li>声明式事务管理：<ul><li>基于TransactionProxyFactoryBean的方式，需要为每个进行事务管理的类做相应配置</li><li>基于AspectJ的XML方式，不需要改动类，在XML文件中配置好即可</li><li>基于注解的方式，配置简单，需要在业务层类中添加注解@Transactional</li></ul></li></ul><h5 id="Spring如何处理线程并发问题？">Spring如何处理线程并发问题？</h5><p>Spring使用ThreadLocal解决线程安全问题</p><p>​	在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h5 id="动态代理与cglib实现的区别？">动态代理与cglib实现的区别？</h5><ul><li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li><li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成final</li></ul><h3 id="SpringMVC面试题">SpringMVC面试题</h3><h5 id="springmvc运行流程？">springmvc运行流程？</h5><ol><li>用户发起请求到前端控制器（DispatcherServlet）</li><li>前端控制器（DispatcherServlet）请求处理器映射器（HandlerMapping）查找Handler，可以是根据xml查找，也可以是根据注解查找</li><li>处理器映射器（HandlerMapping）向前端控制器（DispatcherServlet）返回Handler</li><li>前端控制器调用处理器适配器去执行Handler</li><li>处理器适配器去执行Handler</li><li>Handler执行完成给适配器返回ModelAndView</li><li>处理器适配器向前端控制器返回ModelAndView。（ ModelAndView是springmvc框架的一个底层对象，包括Model和view）</li><li>前端控制器（DispatcherServlet）请求视图解析器（ViewReslover）去进行视图解析（根据逻辑视图解析成真正的物理视图 Jsp等）</li><li>视图解析器（ViewReslover）向前端控制器返回具体 View 对象。</li><li>前端控制器（DispatcherServlet）对 View 进行渲染视图（即将模型数据填充至request域）。</li><li>前端控制器（DispatcherServlet）向用户响应结果</li></ol><h5 id="Spring-MVC的主要组件有哪些？分别简述一下">Spring MVC的主要组件有哪些？分别简述一下</h5><p>前端控制器（DispatcherServlet）：主要负责捕获来自客户端的请求和调度各个组件。</p><p>处理器映射器（HandlerMapping）：根据url查找后端控制器Handler。</p><p>处理器适配器（HandlerAdapter）：执行后端控制器（Handler），拿到后端控制器返回的结果ModelAndView后将结果返回给前端控制器DispatcherServlet。</p><p>后端控制器（处理器）（Handler）：主要负责处理前端请求，完成业务逻辑，生成ModelAndView对象返回给HandlerAdapter。</p><p>视图解析器（ViewResolver）：主要负责将从DispatcherServlet中拿到的ModelAndView对象进行解析，生成View对象返回给DispatcherServlet。</p><h5 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？">如何解决POST请求中文乱码问题，GET的又如何处理呢？</h5><p>解决post请求乱码问题：</p><p>​	在web.xml中配置一个CharacterEncodingFilter过滤器，设置成UTF-8。</p><p>get请求中文参数出现乱码解决方法有两个：</p><p>​	①修改tomcat配置文件添加编码与工程编码一致，如下：</p><p>​ &lt;ConnectorURIEncoding=“UTF-8” connectionTimeout=“20000” port=“8080” protocol=“HTTP/1.1” redirectPort=“8443”/&gt;</p><p>​	②另外一种方法对参数进行重新编码：</p><p>​ String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)</p><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><h5 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h5><p>默认是单例模式的。</p><p>所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的。</p><p>解决方案是在控制器里面不能写成员变量。</p><h5 id="6、-SpringMVC常用的注解有哪些？">6、 SpringMVC常用的注解有哪些？</h5><h5 id="7、SpringMvc里面拦截器是怎么写？">7、SpringMvc里面拦截器是怎么写？</h5><h5 id="8、springmvc-DispatcherServlet与handlerAdapter如何关联">8、springmvc DispatcherServlet与handlerAdapter如何关联?</h5><h5 id="9、有了springmvc的IOC容器-还需要spring的IOC容器吗-为什么-如何处理兼容问题">9、有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?</h5><h5 id="10、Spring-MVC-怎么做异常处理？">10、Spring MVC 怎么做异常处理？</h5><h3 id="Java线程有关面试题">Java线程有关面试题</h3><h5 id="简单说说线程的几种状态-以及线程的阻塞的方式">简单说说线程的几种状态 以及线程的阻塞的方式</h5><p><strong>Java中线程的状态分为5种：</strong></p><p>​	<strong>新建状态</strong>：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态，通过调用start方法进入就绪状态<br>​	<strong>就绪状态</strong>：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU，一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</p><p>​	<strong>运行状态</strong>：线程获得了cpu的调度，执行run()方法中的任务。</p><p>​	<strong>阻塞状态</strong>：处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，让出CPU并暂时停止自己的运行。</p><p>​	<strong>死亡状态</strong>：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。</p><p><strong>阻塞的方式：</strong></p><p>​	线程睡眠：Thread.<strong>sleep</strong> (long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位</p><p>​	线程等待：Object类中的**wait()**方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。</p><p>​	线程自闭，**join()**方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><h5 id="线程有哪些状态？并简单解释一下每个状态">线程有哪些状态？并简单解释一下每个状态</h5><ol><li><p>**新建(NEW)：**新创建了一个线程对象。</p></li><li><p><strong>运行(RUNNABLE)</strong>：包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程可能正在运行，也可能正在等待系统资源，如等待CPU为它分配时间片。</p></li><li><p><strong>阻塞(BLOCKED)</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。</p></li><li><p><strong>WAITING(等待)</strong>：线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p><strong>TIME_WAITING(超时等待)</strong>：该状态不同于WAITING，它可以在指定的时间内自行返回。</p></li><li><p><strong>TERMINATED(终止)</strong>：该线程已经执行完毕。</p></li></ol><h5 id="什么是多线程环境下的伪共享（false-sharing）？">什么是多线程环境下的伪共享（false sharing）？</h5><p>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。</p><p>伪共享发生在不同处理器上的线程对变量的修改依赖于相同的缓存行</p><p>缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p><h5 id="线程安全的单例模式是怎么实现的？-原理是什么？">线程安全的单例模式是怎么实现的？ 原理是什么？</h5><p>​	作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类，单例模式创建方式分为两大类，饿汉式和懒汉，其中饿汉式比较简单，懒汉式则需要考虑线程安全。</p><p>通过如下几种方式可以实现线程安全：</p><p>​	1、方法中声明synchronized关键字，对单例执行方法进行锁同步</p><p>​	2、使用同步代码块实现实现，3、Double Check Locking 双检查锁机制</p><p>​	4、使用静态内置类实现单例模式</p><p>​	5、序列化与反序列化的单例模式实现</p><p>​	6、使用static代码块实现单例</p><p>​	7、使用枚举数据类型实现单例模式</p><p>​	8、完善使用enum枚举实现单例模式</p><h5 id="线程中wait-和sleep-的区别？">线程中wait 和sleep 的区别？</h5><ol><li>sleep()方法是线程类（Thread）的静态方法，wait()方法是Object类里的方法。</li><li>sleep()方法不会释放锁，wait()方法释放对象锁。</li><li>sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用。</li><li>sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。</li></ol><h5 id="BIO、NIO、AIO-有什么区别？">BIO、NIO、AIO 有什么区别？</h5><p>​	BIO：同步并阻塞，服务器的实现模式是一个连接一个线程，这样的模式很明显的一个缺陷是：由于客户端连接数与服务器线程数成正比关系，可能造成不必要的线程开销，严重的还将导致服务器内存溢出。当然，这种情况可以通过线程池机制改善，但并不能从本质上消除这个弊端。<br>​</p><p>​	NIO：它是同步非阻塞的。而服务器的实现模式是多个请求一个线程，即请求会注册到多路复用器Selector上，多路复用器轮询到连接有IO请求时才启动一个线程处理。</p><p>​	AIO：真正意义上的异步非阻塞，服务器的实现模式为多个有效请求一个线程，客户端的IO请求都是由OS先完成再通知服务器应用去启动线程处理（回调）。</p><h5 id="讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势">讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势</h5><p>​	多线程并发对同一数据操作时，会有概率产生脏数据，从而会有意外情况发生。</p><p>​	解决：实现线程安全的方式有多种，其中在源码中常见的方式是，采用synchronized关键字给代码块或方法加锁，但使用了synchronized 代码块，会导致每次都要进行判断处理，降低了执行效率</p><h5 id="请说出你所知道的线程同步的方法">请说出你所知道的线程同步的方法</h5><ol><li>同步方法：即有synchronized关键字修饰的方法，由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前需要获得内置锁，否则就处于阻塞状态。</li><li>同步代码块：即有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</li><li>使用特殊域变量(volatile)实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值 ，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</li><li>使用重入锁实现线程同步：在JavaSE5.0中新增了一个java.util.concurrent包来支持同步，ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。</li><li>使用局部变量实现线程同步：如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li></ol><h5 id="java有哪些锁？乐观锁-悲观锁-synchronized-可重入锁-读写锁-用过reentrantlock吗？reentrantlock与synmchronized的区别">java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别</h5><p><strong>Java有哪些锁？</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">公平锁：是指按照申请锁的顺序来获取锁</span><br><span class="line">非公平所：线程获取锁的顺序不一定按照申请锁的顺序来的。</span><br><span class="line">独享锁：一次只能被一个线程所访问</span><br><span class="line">共享锁：线程可以被多个线程所持有。</span><br><span class="line">乐观锁：对于一个数据的操作并发，是不会发生修改的。在更新数据的时候，会尝试采用更新，不断重入的方式，更新数据。</span><br><span class="line">悲观锁：对于同一个数据的并发操作，是一定会发生修改的。因此对于同一个数据的并发操作，悲观锁采用加锁的形式。悲观锁认为，不加锁的操作一定会出问题，</span><br><span class="line">分段锁：<span class="number">1.7</span>及之前的concurrenthashmap。并发操作就是分段锁，其思想就是让锁的粒度变小。</span><br><span class="line">偏向锁：是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价</span><br></pre></td></tr></table></figure><p><strong>reentrantlock与synmchronized的区别</strong>？</p><p>​	ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。</p><p>Lock使用起来比较灵活，但是必须有释放锁的配合动作，Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁，Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等。此外，reentrantlock有trylock 和lockinterruptly ，所以对锁的操作更灵活。从功能的角度看，reentrantlock支持公平锁和非公平锁 而synchronized 仅支持非公平锁。</p><h5 id="说说你了解的ThreadLocal的使用场景">说说你了解的ThreadLocal的使用场景</h5><p>​	当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。</p><h5 id="为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）">为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）</h5><p>​	start方法其实是在一个新的操作系统线程上面去调用run方法。换句话说，直接调用run方法而不是调用start方法的话，它并不会开启新的线程，而是在调用run的当前的线程当中执行你的操作。</p><p>调用start() 后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，就是为了实现多线程的优点，没这个start不行。</p><h5 id="java程序中怎么保证多线程的运行安全？">java程序中怎么保证多线程的运行安全？</h5><p>线程的安全性问题体现在：</p><p>​	原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作<br>​	可见性：一个线程对主内存的修改可以及时地被其他线程看到<br>​	有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</p><p>解决办法：<br>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题<br>synchronized、volatile、LOCK，可以解决可见性问题<br>Happens-Before 规则可以解决有序性问题</p><h5 id="什么是死锁？怎么防止死锁">什么是死锁？怎么防止死锁</h5><p>​	线程死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p><p>产生死锁的四个必要条件：</p><ol><li><p>**互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p></li><li><p>**请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p></li><li><p>**不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p>**循环等待条件：**若干进程之间形成一种头尾相接的循环等待资源关系。</p></li></ol><p>如何防止：</p><p>​	在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><h5 id="synchronized-、-volatile-、Lock-、ReentrantLock-的区别是什么？">synchronized 、 volatile 、Lock 、ReentrantLock 的区别是什么？</h5><p>Synchronized和volatile的比较</p><ol><li><p><strong>Synchronized保证内存可见性和操作的原子性，Volatile只能保证内存可见性。</strong></p></li><li><p><strong>volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。）</strong></p></li><li><p><strong>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）</strong></p></li><li><p><strong>volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符</strong></p></li></ol><p>Lock与synchronized的比较</p><ol><li><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p></li><li><p>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。Lock在发生异常时，如果没有主动通过unLock()方法去释放锁，则很可能造成死锁的现象，因此使用Lock时需要在finally块中释放锁</p></li><li><p>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断</p></li><li><p>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</p></li><li><p>Lock可以提高多个线程进行读操作的效率。</p></li></ol><p>Synchronized和ReentrantLock的区别</p><ol><li><code>ReentrantLock</code>显示获得、释放锁，<code>synchronized</code>隐式获得释放锁</li><li><code>ReentrantLock</code>可响应中断、可轮回，<code>synchronized</code>是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</li><li><code>ReentrantLock</code>是<code>API</code>级别的，<code>synchronized</code>是<code>JVM</code>级别的</li></ol><h3 id="Java相关问题面试题">Java相关问题面试题</h3><h5 id="Java中如何实现跨域？">Java中如何实现跨域？</h5><p>​	首先使用过滤器获取请求对象request的信息，比如Origin 字段（表示请求来自哪个源，包括协议、域名、端口），通过预先配置的参数判断请求是否合法，然后设置响应对象response的头信息，从而实现跨域资源请求。</p><h5 id="java中操作字符串都有哪些类？它们之间有什么区别？">java中操作字符串都有哪些类？它们之间有什么区别？</h5><p>String、StringBuffer、StringBuilder</p><p><strong>String</strong> : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。</p><p><strong>StringBuffer</strong> : 对字符串的操作的方法都加了synchronized，保证线程安全。</p><p><strong>StringBuilder</strong> : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。</p><h5 id="两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？">两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？</h5><p>​	不会。<strong>Java里方法的参数传递方式只有一种：值传递。</strong></p><h5 id="一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁">一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁</h5><p>​	可用jedisLock—redis分布式锁实现：<strong>基本原理</strong>：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</strong></p><h5 id="简述-tcp-和-udp的区别？">简述 tcp 和 udp的区别？</h5><ol><li>TCP面向连接（如打电话要先拨号建立连接）UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，即不保证可靠交付</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条TCP连接只能是点到点的。UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP对系统资源要求较多相对于UDP速度慢一点，UDP对系统资源要求较少。</li><li>TCP是面向字节流的，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的。TCP是全双工的可靠信道，UDP是不可靠信道</li></ol><h5 id="什么是-CSRF-攻击，如何避免？">什么是 CSRF 攻击，如何避免？</h5><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，达到攻击目的。比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p><p>避免方法：<br>1. CSRF 漏洞进行检测的工具，如 CSRFTester、CSRF Request Builder…</p><ol start="2"><li>验证 HTTP Referer 字段</li><li>在请求地址中添加 token 并验证</li><li>添加自定义 http 请求头</li><li>敏感操作添加验证码</li><li>使用 post 请求</li><li>只使用JSON API</li></ol><h5 id="tcp为什么要三次握手，两次不行吗？为什么？">tcp为什么要三次握手，两次不行吗？为什么？</h5><p>什么是三次握手?</p><p>​	第一次握手：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号(Seq)里。</p><p>​	第二次握手：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。<br>​	第三次握手：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。</p><p>为什么要三次握手？</p><ul><li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p></li><li><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p></li></ul><p>两次不行吗？为什么？</p><p>​	因为我们不进行第三次握手在服务端对客户端请求进行回应后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务端的回应呢？此时客户端仍认为连接未建立，服务端会对已建立的连接保存必要的资源，如果大量的这种情况，服务端会崩溃。因此第三次握手是必要的。</p><h5 id="java中数组在内存中如何分配？">java中数组在内存中如何分配？</h5><p>​	在使用“new”创建对象时，会在堆中分配一个内存空间并返回一个引用。对于数组也是如此，因为数组是Java中的对象。</p><h5 id="为什么重写equals时必须重写hashCode方法？">为什么重写equals时必须重写hashCode方法？</h5><ol><li>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</li><li>保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</li><li>如果只重写了 equals 方法，两个对象 equals 返回了true，集合是不允许出现重复元素的，只能插入一个。</li></ol><h5 id="解释Java堆空间及GC"><strong>解释Java堆空间及GC</strong></h5><p>​	Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。<br>​	在 Java 中，堆被划分成两个不同的区域：新生代和老年代。而新生代又可以划分为Eden区、SurvivorFrom区、SurvivorTo区。而整个区域的比例应该是新生代比老年代为1:2，而Eden比SurvivorFrom比SurvivorTo为8:1:1。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p><p>​	Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法，它是java虚拟机自己使用的守护线程。负责清理所谓的&quot;不可达&quot;的对象。当程序创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。当GC确定一些对象为&quot;不可达&quot;时，GC就有责任回收这些内存空间。</p><h5 id="谈谈你对Java垃圾回收机制的了解">谈谈你对Java垃圾回收机制的了解</h5><p>​	在系统运行过程中，会产生一些无用的对象，这些对象占据着一定的内存，如果不对这些对象清理回收无用对象的内存，可能会导致内存的耗尽，所以垃圾回收机制回收的是内存。同时GC回收的是堆区和方法区的内存。在CPU空闲时或者堆内存满了就会自动调用System.gc()进行回收，一共有标记－清理，标记 - 复制，标记－整理，分代<strong>回收机制</strong>，多种垃圾回收算法。</p><h5 id="讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类">讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类</h5><p><strong>static</strong></p><p>​	1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</p><p>​	2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p><p>​	3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p><p>​	4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><p><strong>final</strong></p><p>​	1、final修饰一个类时，表明这个类不能被继承。</p><p>​	2、final修饰方法，方法不可以重写，但是可以被子类访问 【前提：方法不是 private 类型】。</p><p>​	3、如果被final修饰的是<strong>基本数据类型</strong>的变量，则其数值一旦在初始化之后便不能更改；如果是<strong>引用类型</strong>的变量，则在对其初始化之后便不能再让其指向另一个对象。</p><p>Java中使用final修饰的类：String，Math，Integer等，这样可以防止对系统造成危害。</p><h3 id="Java集合面试题">Java集合面试题</h3><h5 id="List-和-Set-的区别？">List 和 Set 的区别？</h5><p>1、重复对象：<br>list方法可以允许重复的对象，set方法不允许重复对象</p><p>2、可插入的null元素不同：<br>list可以插入多个null元素，而set值允许插入一个null元素</p><p>3、容器是否有序不同：<br>list是有序容器，保持每个元素的插入顺序，即输出顺序就是输入顺序，而set方法	是无序容器，无法保证每个元素的存储顺序，TreeSet通过Compaator或者 Comparable维护一个排序顺序</p><p>4、常用的实现类不同：<br>list方法常用的实现类有ArrayList、LinkedList 和 Vector。其中ArrayList 最为流行，它提供了使用索引的随意访问，而LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适，Vector 表示底层数组，线程安全</p><p>​ Set方法中最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和compareTo() 的定义进行排序的有序容器</p><h5 id="HashSet-是如何保证不重复的">HashSet 是如何保证不重复的</h5><p>​	首先会调用Object的hashCode方法判hashCode是否已经存在，如不存在则直接插入元素；</p><p>​	如果已存在则调用Object对象的equals方法判断是否返回true，如果为true则说明元素已经存在，如为false则插入元素。</p><p>HashSet在内部实例化了一个HashMap对象。HashMap的key是不能重复的，而这里HashSet的元素又是作为了map的key，当然也不能重复了。</p><h5 id="java中几种集合的区别以及底层实现是什么样的？">java中几种集合的区别以及底层实现是什么样的？</h5><p>Java中的集合包括三大类，它们是Set、List和Map，它们都处于java.util包中，Set、List和Map都是接口，它们有各自的实现类。Set的实现类主要有HashSet和TreeSet，List的实现类主要有ArrayList，Map的实现类主要有HashMap和TreeMap。</p><h5 id="ArrayList实现原理">ArrayList实现原理</h5><ol><li>ArrayList是List接口的可变数组非同步实现，并允许包括null在内的所有元素。</li><li>底层使用数组实现</li><li>该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。</li><li>采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li><li>remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GC</li></ol><h5 id="HashMap实现原理">HashMap实现原理</h5><ol><li>HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。</li><li>底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。</li><li>HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。</li><li>HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能</li><li>采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常</li></ol><h5 id="HashSet实现原理">HashSet实现原理</h5><ol><li>HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。</li><li>基于HashMap实现，API也是对HashMap的行为进行了封装，可参考HashMap</li></ol><h5 id="简单说说hashmap的底层实现原理">简单说说hashmap的底层实现原理</h5><p>​	首先有一个每个元素都是链表的数组，当添加一个元素时，就首先计算元素key的hash值，以此确定插入数组中的位置，但可能存在同一hash值的元素已经被放到数组的同一位置了，这时就添加到同一hash值的元素后面，他们在数组的同一位置，但是行成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中。</p><h3 id="缓存面试题">缓存面试题</h3><h5 id="简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？">简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？</h5><p>memcache和redis的两种缓存的区别？</p><p>​	1、在Redis中，不是所有的数据都一直存储在内存中的，这是和Memcache相比一个最大的区别。</p><p>​	2、Reids在很多方面具备数据库的特征， 支持多种数据结构，而Memcache只是简单的K/V缓存。</p><p>​	3、在100k以上的数据中，Memcache性能要高于Redis。</p><p>​	4、在内存使用效率的话，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcache。当然，这和你的应用场景和数据特性有关。</p><p>​	5、存储数据安全—memcache挂掉后，数据没了，redis可以定期保存到磁盘（持久化）</p><p>​	6、灾难恢复—memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复</p><p><strong>对于两者的选择还是要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，我在项目里还是采用memcache，它也足够的稳定可靠。如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。</strong></p><h3 id="MySQL面试题">MySQL面试题</h3><h5 id="你了解的Mysql的几种引擎？-分别适合什么样的数据库">你了解的Mysql的几种引擎？ 分别适合什么样的数据库</h5><p>MyISAM(默认引擎)：查询性能高，并发修改数据性能低、不支持外键、不支持事务。</p><p>INNODB：修改数据性能高，支持事务，支持外键、查询性能相对MyISAM要低;</p><p>MEMORY： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p><p>分别适用？</p><p>​	MyISAM：如果这个数据库中查询要求比较高可以选择MyISAM存储，因为其特性在做数据库读写分离时通常会把读取的表的存储引擎设置为MyISAM。</p><p>​	INNODB：如果需要比较高的事务处理，高并发写的业务场景，可以选择InnoDB。</p><p>​	MEMORY：如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p><h5 id="mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的">mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的</h5><p>​	1、避免 SELECT *，需要什么数据，就查询对应的字段。</p><p>​	2、利用自增主键索引、<code>order by</code>加<code>limit</code>，不使用offset</p><p>​	3、在性能要求比较高的场景中，杜绝查询中使用<code>临时表</code></p><p>​	4、使用 EXPLAIN 关键字分析SQL语句性能。</p><h5 id="简单讲讲mysql的锁机制以及的行级锁加在哪个位置？">简单讲讲mysql的锁机制以及的行级锁加在哪个位置？</h5><p>锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性，MySQL的锁机制最显著的特点是不同的存储引擎支持不同的锁机制，比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（ row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p><p>MySQL大致可归纳为以下3种锁：<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><p>行级锁加在哪个位置？</p><p>​	InnoDB行锁是通过给索引上的<code>索引项加锁</code>来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。</p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurityOAuth2.0认证授权</title>
    <url>/blog/posts/1144715794/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:51 GMT+0800 (GMT+08:00) --><blockquote><p>因项目需求需要用到，在网上学习Spring Security OAuth2.0 完之后做一下总结和整理，首先说一下关于认证授权的基本概念。</p></blockquote><a id="more"></a><!-- more --><h3 id="1-基本概念">1.基本概念</h3><h5 id="什么是认证">什么是认证?</h5><p>​	进入移动互联网时代，大家每天都在刷手机，常用的软件有微信、支付宝、头条等,下边拿微信来举例子说明认证 相关的基本概念，在初次使用微信前需要注册成为微信用户，然后输入账号和密码即可登录微信，输入账号和密码 登录微信的过程就是认证。</p><p><code>系统为什么要认证</code>？</p><p>​	认证是为了保护系统的隐私数据与资源，用户的身份合法方可访问该系统的资源。</p><p><code>认证</code>：用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信 息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有:用户名密码登录，二维码登录，手 机短信登录*，*指纹认证等方式。</p><h5 id="什么是会话">什么是会话?</h5><p>​	用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。会话就是系统为了保持当前用户的登录状态所提供的机制，常见的有基于session方式、基于token方式等。</p><p>基于session的认证方式如下图：<br>它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端的sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了。</p><p>​	<img src="/blog/posts/1144715794/1.jpg" alt="1"></p><p>基于token方式如下图：</p><p>​	它的交互流程是，用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。<br>​	<img src="/blog/posts/1144715794/2.jpg" alt="2"></p><p>基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持<br>cookie；基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式。如今移动互联网时代，更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合。</p><h5 id="什么是授权？">什么是授权？</h5><p>​	比如微信登录成功后用户即可使用微信的功能，如：发红包、发朋友圈、添加好友等，如未绑定银行卡用户则无法发送红包，绑定银行卡的用户才可以发红包，发红包功能、发朋友圈功能都是微信的资源即<code>功能资源</code>，用户拥有发红包功能的权限才可以正常使用发送红包功能，这个<code>根据用户的权限来控制用户使用资源的过程就是授权。</code></p><h5 id="为什么要授权？">为什么要授权？</h5><p>​	认证是为了保证用户身份的合法性，授权则是为了更细粒度的对隐私数据进行划分，授权是在认证通过后发生的，控制不同的用户能够访问不同的资源。</p><p><strong>授权</strong>： 授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有权限则拒绝访问。</p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Java权限框架</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud+Spring Security OAuth2 实现微服务统一认证授权</title>
    <url>/blog/posts/182718243/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><blockquote><p>目前正在做了一个基于Spring Cloud的微服务项目，现在的好多项目都是基于APP移动端以及前后端分离的项目，之前基于Session的前后端放到一起的项目已经慢慢失宠并淡出我们视线，尤其是当基于SpringCloud的微服务架构以及Vue、React单页面应用流行起来，为此基于前后端分离的项目用户认证也受到众人关注的一个焦点，我们先来聊一聊在分布式项目认证需求以及解决方案。</p></blockquote><a id="more"></a><!-- more --><h4 id="分布式认证需求">分布式认证需求</h4><p>​	分布式系统的每个服务都会有认证、授权的需求，如果每个服务都实现一套认证授权逻辑会非常冗余，考虑分布式系统共享性的特点，需要由独立的认证服务处理系统认证授权的请求；考虑分布式系统开放性的特点，不仅对系统内部服务提供认证，对第三方系统也要提供认证。分布式认证的需求总结如下：</p><p><code>统一认证授权</code></p><p>​	提供独立的认证服务，统一处理认证授权。</p><p>​	无论是不同类型的用户，还是不同种类的客户端(web端，H5、APP)，均采用一致的认证、权限、会话机制，实现统一认证授权。</p><p>​	要实现统一则认证方式必须可扩展，支持各种认证需求，比如：用户名密码认证、短信验证码、二维码、人脸识别等认证方式，并可以非常灵活的切换</p><p><code>应用接入认证</code></p><p>​	应提供扩展和开放能力，提供安全的系统对接机制，并可开放部分API给接入第三方使用，一方应用（内部 系统服务）和三方应用（第三方应用）均采用统一机制接入。</p><h4></h4><h4 id="分布式认证方案">分布式认证方案</h4><p><code>基于session的认证方式</code></p><p>​	在分布式的环境下，基于session的认证会出现一个问题，每个应用服务都需要在session中存储用户身份信息，通过负载均衡将本地的请求分配到另一个应用服务需要将session信息带过去，否则会重新认证。</p><p>这个时候，通常的做法有下面几种：</p><ul><li><code>Session复制</code>：多台应用服务器之间同步session，使session保持一致，对外透明</li><li><code>Session黏贴</code>：当用户访问集群中某台服务器后，强制指定后续所有请求均落到此机器上。</li><li><code>Session集中存储</code>：将Session存入分布式缓存中，所有服务器应用实例统一从分布式缓存中存取Session。</li></ul><p>总体来讲，基于session认证的认证方式，可以更好的在服务端对会话进行控制，且安全性较高。但是，session机制方式基于cookie，在复杂多样的移动客户端上不能有效的使用，并且无法跨域，另外随着系统的扩展需提高session的复制、黏贴及存储的容错性。</p><p><code>基于token的认证方式</code></p><p>​	基于token的认证方式，服务端不用存储认证数据，易维护扩展性强， 客户端可以把token 存在任意地方，并且可以实现web和app统一认证机制。其缺点也很明显，token由于自包含信息，因此一般数据量较大，而且每次请求都需要传递，因此比较占带宽。另外，token的签名验签操作也会给cpu带来额外的处理负担。</p><p>在分析完这两种认证方式之后，决定采用基于token的认证方式，它的优点更符合我们分布式认证方案：</p><ol><li>适合统一认证的机制，客户端、一方应用、三方应用都遵循一致的认证机制</li><li>token认证方式对第三方应用接入更适合，因为它更开放，可使用当前有流行的开放协议Oauth2.0、JWT等</li><li>一般情况服务端无需存储会话信息，减轻了服务端的压力。</li></ol><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
  </entry>
  <entry>
    <title>微服务/认识微服务</title>
    <url>/blog/posts/3160502620/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><h2 id="认识微服务">认识微服务</h2><blockquote><p>在当今互联网发展中，微服务架构已经流行了很长一段时间了，接下来我们来聊一聊什么是微服务。</p></blockquote><a id="more"></a><!-- more --><h3 id="微服务的基本概念">微服务的基本概念</h3><hr><h4 id="1、微服务架构的定义">1、微服务架构的定义</h4><p><code>微服务</code>一词源自 马丁·福勒（Martin Fowler) 和 James Lewis共同提出，在2014年3月25日写的一篇博客：<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices</a> 该文章中对微服务定义如下：</p><blockquote><p>the microservice architectural style [1] is an approach to developing<br>a single application as a suite of small services, each running in its<br>own process and communicating with lightweight mechanisms, often an<br>HTTP resource API. These services are built around business<br>capabilities and independently deployable by fully automated<br>deployment machinery. There is a bare minimum of centralized<br>management of these services, which may be written in different<br>programming languages and use different data storage technologies.</p></blockquote><p>微服务架构风格是将单体应用程序拆分为<strong>多个小型的服务</strong> 并且每个服务在<strong>独立的进程</strong>中。服务间的通信采用<strong>轻量级通信</strong>的机制 通常是HTTP方式提供API 来实现。这些服务通过自动化部署的方式进行<strong>独立部署</strong>。每个服务可以根据自身的特点采用不同的语言开发同时也可以使用不同的数据存储技术。</p><p>微服务是一种架构风格：没有强制性，没有绝对标准，并不是具体的某一个框架或组件。</p><p><code>Martin Fowler</code>在他的博客中为微服务架构总结了六个特点：</p><ul><li><p>一组小的服务</p></li><li><p>独立的进程</p></li><li><p>轻量级通信（通常是HTTP/JSON）</p></li><li><p>基于业务能力（每个服务为独立的业务开发）</p></li><li><p>独立部署</p></li><li><p>无集中式管理（分布式的管理，每个服务可以使用不同的语言，不同的存储技术）</p></li></ul><p><code>Adrian Cockcroft</code> 更是将微服务比喻成 细粒度的 SOA（面向服务的架构，SOA理念，更细化、更落地）</p><p>虽然对微服务的定义进行解释，但是如果想更深层次的了解微服务 我们不得不先从单体架构说起。</p><hr><h4 id="2、单体架构的定义">2、单体架构的定义</h4><p>一个归档包（例如war格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之为单体应用架构。</p><p><code>单体架构好处：</code></p><ul><li><code>IDE友好支持</code>：NetBeans、Eclipse、IntelliJ 这样工具专门为单体应用设计。 你只需要使用其中一种 就可以在你本地机器上进行 开发 调试 部署。</li><li><code>方便测试</code>：测试人员只需要测试单个应用即可。新开发的功能部署完成就可以测试所有的功能。</li><li><code>容易部署</code>：打包成war包放入我们的服务器 或者打包成一个可执行的jar 执行jar包即可。</li></ul><p><code>单体架构缺点：</code></p><ol><li>复杂性高<br>以笔者经手的一个百万行级别的单体应用为例，整个项目包含的模块非常多，模块的边界模糊，依赖关系不清晰，代码质量参差不齐，混乱地堆砌在一起……整个项目非常复杂。每次修改代码都心惊胆战，甚至添加一个简单的功能，或者修改一个BUG都会造成隐含的缺陷。</li><li>技术债务<br>随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。“不坏不修（Not broken，don’t fix）”，这在软件开发中非常常见，在单体应用中这种思想更甚。已使用的系统设计或代码难以修改，因为应用程序的其他模块可能会以意料之外的方式使用它。</li><li>部署频率低<br>随着代码的增多，构建和部署的时间也会增加。而在单体应用中，每次功能的变更或缺陷的修复都会导致我们需要重新部署整个应用。全量部署的方式耗时长、影响的范围大、风险高，这使得单体应用项目上线部署的频率较低。而部署频率低又导致两次发布之间会有大量的功能变更和缺陷修复，出错概率比较高。</li><li>扩展能力受限<br>单体应用只能作为一个整体进行扩展，无法结合业务模块的特点进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU；有的模块则是IO密集型的，需要更大的内存。由于这些模块部署在一起，我们不得不在硬件的选择上做出妥协。</li><li>阻碍技术创新<br>单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和框架，想要引入新的框架或技术平台会非常困难。例如，一个使用Struts 2构建的、100万行代码的单体应用，如果想要换用Spring MVC，切换成本无疑是非常高的。</li></ol><p>为了解决以上这些问题，服务化的思想也就应运而生。<br>服务化的思想就是将单机应用中的本地方法调用改造为通过RPC接口来进行远程方法调用。以改造调用方式的方法将业务从单体应用中拆分出来，独立成一个服务部署。</p><hr><h4 id="3、什么是微服务">3、什么是微服务</h4><p>微服务是服务化思想的进一步演化。与服务化对比微服务有以下几个特点：</p><ol><li><code>服务拆分粒度更细</code>：微服务可以说是更细维度的服务化，小到一个子模块，只要该模块以来的资源与其他模块都没有关系，那么就可以拆分为一个微服务。</li><li><code>服务独立部署</code>：每个微服务都严格遵循独立打包部署的准则，互不影响。</li><li><code>服务独立维护</code>：每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。</li><li><code>服务治理能力要求高</code>：因为拆分为微服务之后，服务的数量变多，因此需要有同意的服务治理平台，来对各个服务进行管理。</li></ol><h6 id="微服务架构的优点：">微服务架构的优点：</h6><ol><li>每个服务都比较简单，只关注于一个业务功能。</li><li>微服务架构方式是松耦合的，可以提供更高的灵活性。</li><li>微服务可通过最佳及最合适的不同的编程语言与工具进行开发，能够做到有的放矢地解决针对性问题。</li><li>每个微服务可由不同团队独立开发，互不影响，加快推出市场的速度。</li><li>微服务架构是持续交付(CD)的巨大推动力，允许在频繁发布不同服务的同时保持系统其他部分的可用性和稳定性</li></ol><h6 id="微服务架构的缺点：">微服务架构的缺点：</h6><p>​	微服务的一些想法在实践上是好的，但当整体实现时也会呈现出其复杂性。</p><ol><li><code>运维开销及成本增加</code>：整体应用可能只需部署至一小片应用服务区集群，而微服务架构可能变成需要构建/测试/部署/运行数十个独立的服务，并可能需要支持多种语言和环境。这导致一个整体式系统如果由20个微服务组成，可能需要40~60个进程。</li><li><code>必须有坚实的DevOps开发运维一体化技能</code>：开发人员需要熟知运维与投产环境，开发人员也需要掌握必要的数据存储技术如NoSQL，具有较强DevOps技能的人员比较稀缺，会带来招聘人才方面的挑战。</li><li><code>隐式接口及接口匹配问题</code>：把系统分为多个协作组件后会产生新的接口，这意味着简单的交叉变化可能需要改变许多组件，并需协调一起发布。在实际环境中，一个新品发布可能被迫同时发布大量服务，由于集成点的大量增加，微服务架构会有更高的发布风险。</li><li><code>代码重复</code>：某些底层功能需要被多个服务所用，为了避免将“同步耦合引入到系统中”，有时需要向不同服务添加一些代码，这就会导致代码重复。</li><li><code>分布式系统的复杂性</code>：作为一种分布式系统，微服务引入了复杂性和其他若干问题，例如网络延迟、容错性、消息序列化、不可靠的网络、异步机制、版本化、差异化的工作负载等，开发人员需要考虑以上的分布式系统问题。</li><li><code>异步机制</code>：微服务往往使用异步编程、消息与并行机制，如果应用存在跨微服务的事务性处理，其实现机制会变得复杂化。</li><li><code>可测性的挑战</code>：在动态环境下服务间的交互会产生非常微妙的行为，难以可视化及全面测试。经典微服务往往不太重视测试，更多的是通过监控发现生产环境的异常，进而快速回滚或采取其他必要的行动。但对于特别在意风险规避监管或投产环境错误会产生显著影响的场景下需要特别注意。</li></ol><h6 id="关于微服务架构的取舍">关于微服务架构的取舍</h6><ol><li>在合适的项目，合适的团队，采用微服务架构收益会大于成本。</li><li>微服务架构有很多吸引人的地方，但在拥抱微服务之前，也需要认清它所带来的挑战。</li><li>需要避免为了“微服务”而“微服务”。</li><li>微服务架构引入策略 – 对传统企业而言，开始时可以考虑引入部分合适的微服务架构原则对已有系统进行改造或新建微服务应用，逐步探索及积累微服务架构经验，而非全盘实施微服务架构。</li></ol><h4 id="总结"><strong>总结</strong></h4><p>​	架构选择的优劣只有在系统使用几年后才能真正显现出来，并不是说以前的单体架构就一无是处，通过真确的业务理解，优秀的设计，专业的开发人员。单体应用一样可以支撑业务，同样，对于微服务架构，一个蹩脚的架构设计，一样会导致低劣的产品出来。要知道，微服务各个组件之间的交互是很复杂的，难以管理和控制。</p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>Shiro基本概述</title>
    <url>/blog/posts/2087459868/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><blockquote><p>最近学习的Shiro安全框架，打算把现有的知识梳理一下，下面我们来了解一下shiro这个<strong>强大且易用的Java安全框架</strong>。</p></blockquote><h2 id="Shiro介绍">Shiro介绍</h2><p>​	Shiro是一个Java安全框架，可以帮助我们完成：执行身份验证、授权、密码、会话管理等。</p><p>​	Shiro是Apache 的一个开源项目，前身是JSecurity 项目，始于2003年初。</p><p>​	Shiro 可以为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。</p><p>shiro 解决了应用安全的<code>四要素</code>：</p><ul><li>认证 - 用户身份识别，常被称为用户“登录”；</li><li>授权 - 访问控制；</li><li>密码加密 - 保护或隐藏数据防止被偷窥；</li><li>会话管理 - 每用户相关的时间敏感的状态。</li></ul><p>同时，Shiro另外支持了一些辅助特性：如 Web 应用安全、单元测试和多线程，它们的存在强化了上面提到的四个要素。Shiro的API也是非常简单；其基本功能点如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20191128001112422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Authentication</strong>：<code>身份认证/登录</code>，验证用户是不是拥有相应的身份；</p><p><strong>Authorization</strong>：<code>授权</code>，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><p><strong>Session Manager</strong>：<code>会话管理</code>，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</p><p><strong>Cryptography</strong>：<code>加密</code>，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p><p><strong>Web Support</strong>：<code>Web支持</code>，可以非常容易的集成到Web环境；</p><p><strong>Caching</strong>：<code>缓存</code>，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</p><p><strong>Concurrency</strong>：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</p><p><strong>Testing</strong>：提供测试支持；</p><p><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</p><p><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</p><p><strong>记住一点，Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。</strong></p><hr><h5 id="Shiro包含了三个核心概念：Subject-SecurityManager-和-Realms。">Shiro包含了三个核心概念：<code>Subject</code>,<code>SecurityManager</code> 和 <code>Realms</code>。</h5><ul><li>Subject：主体，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是其他的程序。Subject 代表了当前用户的安全操作。</li><li>SecurityManager则管理所有用户的安全操作。它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。</li><li>Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。</li></ul><p>一般我们需要继承 <code>org.apache.shiro.realm.AuthorizingRealm</code>,然后实现其中父类的2个抽象方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录及权限验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色权限和对应权限添加</span></span><br><span class="line">    <span class="comment">//Authorization授权，将数据库中的角色和权限授权给输入的用户名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行授权逻辑"</span>);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户身份验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行认证逻辑"</span>);</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="整体流程">整体流程</h2><p>用户通过Subject来进行认证和授权，而Subject又委托给SecurityManager，而SecurityManager又需要通过我们自定义的Realm来获取密码，权限等数据来进行校验和比对。<br><img src="https://img-blog.csdnimg.cn/20191128001502325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pob3VYaWFuQmlhbw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h2 id="过滤器和权限拦截器">过滤器<strong>和权限拦截器</strong></h2><h6 id="Shiro还提供了过滤器，可以配置我们的过滤规则">Shiro还提供了过滤器，可以配置我们的过滤规则</h6><table><thead><tr><th>过滤器简称</th><th style="text-align:left">对应的java类</th><th style="text-align:center">参数概述</th></tr></thead><tbody><tr><td>anon</td><td style="text-align:left">org.apache.shiro.web.filter.authc.AnonymousFilter</td><td style="text-align:center">没有参数，表示可以匿名使用。</td></tr><tr><td>authc</td><td style="text-align:left">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td><td style="text-align:center">表示需要认证(登录)才能使用，没有参数</td></tr><tr><td>authcBasic</td><td style="text-align:left">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td><td style="text-align:center">没有参数表示httpBasic认证</td></tr><tr><td>perms</td><td style="text-align:left">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td><td style="text-align:center">参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割</td></tr><tr><td>port</td><td style="text-align:left">org.apache.shiro.web.filter.authz.PortFilter</td><td style="text-align:center">port[8081],当请求的url的端口不是8081是跳转到schemal</td></tr><tr><td>rest</td><td style="text-align:left">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td><td style="text-align:center">根据请求的方法，相当于/admins/user/**=perms[user:method]</td></tr><tr><td>roles</td><td style="text-align:left">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td><td style="text-align:center">参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割</td></tr><tr><td>ssl</td><td style="text-align:left">org.apache.shiro.web.filter.authz.SslFilter</td><td style="text-align:center">没有参数，表示安全的url请求，协议为https</td></tr><tr><td>user</td><td style="text-align:left">org.apache.shiro.web.filter.authc.UserFilter</td><td style="text-align:center">没有参数表示必须存在用户，当登入操作时不做检查</td></tr><tr><td>logout</td><td style="text-align:left">org.apache.shiro.web.filter.authc.LogoutFilter</td><td style="text-align:center">退出清除HTTPSession数据</td></tr></tbody></table><p>我们也可以自定义实现过滤器，如果是授权相关，则继承<code>org.apache.shiro.web.filter.authz.AuthorizationFilter</code>，如果是认证则继承<code>AuthenticatingFilter</code></p><hr><h6 id="前端Shiro标签"><strong>前端Shiro标签</strong></h6><table><thead><tr><th><strong>标签名称</strong></th><th><strong>标签条件（均是显示标签内容）</strong></th></tr></thead><tbody><tr><td>&lt;shiro:authenticated &gt;</td><td>登录之后</td></tr><tr><td>&lt;shiro:notAuthenticated &gt;</td><td>不在登录状态时</td></tr><tr><td>&lt;shiro:guest &gt;</td><td>用户在没有RememberMe时</td></tr><tr><td>&lt;shiro:user &gt;</td><td>用户在RememberMe时</td></tr><tr><td>&lt;shiro:hasAnyRoles name=“abc,123” &gt;</td><td>在有abc或者123角色时</td></tr><tr><td>&lt;shiro:hasRole name=“abc”&gt;</td><td>拥有角色abc</td></tr><tr><td>&lt;shiro:lacksRole name=“abc”&gt;</td><td>没有角色abc</td></tr><tr><td>&lt;shiro:hasPermission name=“abc”&gt;</td><td>拥有权限资源abc</td></tr><tr><td>&lt;shiro:lacksPermission name=“abc”&gt;</td><td>没有abc权限资源</td></tr><tr><td>&lt;shiro:principal &gt;</td><td>默认显示用户名称</td></tr></tbody></table><p>基本聊完之后我们来看看另一个安全框架与shiro的一些区别。</p><hr><h4 id="Spring-security和Apache-shiro比较"><strong>Spring security和Apache shiro比较</strong></h4><ol><li>shiro配置更加容易理解，容易上手，相比之下Spring security配置相对比较难懂。</li><li>在spring的环境下，security整合性更好。Shiro对很多其他的框架兼容性更好，号称是无缝集成。</li><li><code>Spring</code>以简单而闻名，但讽刺的是很多人发现安装Spring Security很难,然而Spring Security却有更好的社区支持</li><li>Shiro提供的密码加密使用起来非常方便。</li><li>Shiro 功能强大、且 简单、灵活。且不跟任何的框架或者容器绑定，可以独立运行。</li></ol><hr><h5 id="实现参考下一篇：springboot整合shiro实现权限控制。">实现参考下一篇：springboot整合shiro实现权限控制。</h5><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Java权限框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/blog/posts/1243066710/</url>
    <content><![CDATA[<!-- build time:Mon May 18 2020 23:30:52 GMT+0800 (GMT+08:00) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<a id="more"></a></p><h2 id="Quick-Start-more">Quick Start<!-- more --></h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat --><link rel="stylesheet" href="/blog/css/spoiler.css" type="text/css"><script src="/blog/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
