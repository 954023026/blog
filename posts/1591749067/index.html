<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://954023026.github.io').hostname,
    root: '/blog/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="经典面试题整理 MyBatis面试题 #{} 和 ${} 的区别是什么？   #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。$将传入的数据直接显示生成在sql中。   #方式能够很大程度防止sql注入，$方式无法防止Sql注入。   mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。   Mybatis在处理">
<meta property="og:type" content="article">
<meta property="og:title" content="经典面试题整理">
<meta property="og:url" content="https://954023026.github.io/posts/1591749067/index.html">
<meta property="og:site_name" content="一个BUG搞一天。">
<meta property="og:description" content="经典面试题整理 MyBatis面试题 #{} 和 ${} 的区别是什么？   #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。$将传入的数据直接显示生成在sql中。   #方式能够很大程度防止sql注入，$方式无法防止Sql注入。   mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。   Mybatis在处理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://954023026.github.io/blog/posts/1591749067/1586619066544.png">
<meta property="article:published_time" content="2020-04-26T06:05:17.486Z">
<meta property="article:modified_time" content="2020-04-26T06:51:50.372Z">
<meta property="article:author" content="微笑">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://954023026.github.io/blog/posts/1591749067/1586619066544.png">

<link rel="canonical" href="https://954023026.github.io/posts/1591749067/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>经典面试题整理 | 一个BUG搞一天。</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个BUG搞一天。</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">让我们一起把代码变的更优雅一点。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/blog/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/954023026/" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://954023026.github.io/posts/1591749067/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="微笑">
      <meta itemprop="description" content="技术博客,Java,记录美好学习时光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个BUG搞一天。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          经典面试题整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-26 06:05:17 / 修改时间：06:51:50" itemprop="dateCreated datePublished" datetime="2020-04-26T06:05:17Z">2020-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>
            </span>

          
            <span id="/blog/posts/1591749067/" class="post-meta-item leancloud_visitors" data-flag-title="经典面试题整理" title="热度">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">热度：</span>
              <span class="leancloud-visitors-count"></span>
              <span>℃</span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/blog/posts/1591749067/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/blog/posts/1591749067/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k 字</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1>经典面试题整理</h1>
<h3 id="MyBatis面试题">MyBatis面试题</h3>
<h5 id="和-的区别是什么？">#{} 和 ${} 的区别是什么？</h5>
<ol>
<li>
<p>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。$将传入的数据直接显示生成在sql中。</p>
</li>
<li>
<p>#方式能够很大程度防止sql注入，$方式无法防止Sql注入。</p>
</li>
<li>
<p>mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p>
</li>
<li>
<p>Mybatis在处理 ${} 时，就是把${}替换成变量的值,直接进行sql拼接。</p>
</li>
<li>
<p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
</li>
</ol>
<a id="more"></a>
<!-- more -->
<h5 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？">介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h5>
<p>1.一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>2.二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置</p>
<p>3.对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h5 id="介绍一下MyBatis的缓存？">介绍一下MyBatis的缓存？</h5>
<p>MyBatis将数据缓存设计成两级结构，分为一级缓存、二级缓存，在mybatis中一级缓存默认开始，二级缓存需要配置。</p>
<p>一级缓存是Session会话级别的缓存，位于表示一次数据库会话的SqlSession对象之中，又被称之为本地缓存。一级缓存是MyBatis内部实现的一个特性，用户不能配置，默认情况下自动支持的缓存，用户没有定制它的权利（不过这也不是绝对的，可以通过开发插件对它进行修改）</p>
<p>二级缓存是Application应用级别的缓存，它的是生命周期很长，跟Application的生命周期一样，也就是说它的作用范围是整个Application应用，mybatis的二级缓存是多个SqlSession共享，其作用域是mapper的同一个namespace，不同的sqlsession两次执行相同namespace下的sql语句，且向sql语句中传递的参数也相等，最终执行相同的sql语句，第一次执行完毕后会将从数据库查询到的数据写到缓存（内存）中，第二次会存缓存中获取数据而不再进行数据库查询，从而提高查询效率。</p>
<h5 id="MyBatis-执行批量插入有哪些方式？-优缺点是什么">MyBatis 执行批量插入有哪些方式？ 优缺点是什么?</h5>
<p>​	<strong>mybiats foreach标签</strong></p>
<p>​			foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。</p>
<p>​	<strong>mybatis ExecutorType.BATCH</strong></p>
<p>​			Mybatis内置的ExecutorType有3种，默认的是simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p>
<p>​	<strong>xml、注解两种方式的区别：</strong></p>
<ol>
<li>foreach相当语句逐条insert语句执行，将出现如下问题：<br>
mapper接口的insert方法返回值将是最后一条insert语句的操作成功的记录数目（就是0或1），而不是所有insert语句的操作成功的总记录数目；<br>
当其中一条不成功时，不会进行整体回滚。</li>
<li>注解方式：当有一条插入不成功时，会整体回滚。</li>
</ol>
<h5 id="当实体类中的属性名和表中的字段名不一样时有哪些处理方法？">当实体类中的属性名和表中的字段名不一样时有哪些处理方法？</h5>
<ul>
<li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li>
<li>通过来映射字段名和实体类属性名的一一对应的关系</li>
</ul>
<h5 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？">Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h5>
<p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，</p>
<p>Mybatis提供了9种动态sql标签</p>
<p>​	<strong>trim | where | set | foreach | if | choose| when | otherwise | bind</strong></p>
<p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p>
<h5 id="通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？">通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h5>
<ul>
<li>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。</li>
<li>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li>
<li>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</li>
</ul>
<h5 id="Mapper接口绑定有几种实现方式-分别是怎么实现的">Mapper接口绑定有几种实现方式,分别是怎么实现的?</h5>
<p>接口绑定有两种实现方式：<br>
一种是通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</p>
<p>另外一种就是通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</p>
<h5 id="在mybatis中如何获取自动生成的-主-键值">在mybatis中如何获取自动生成的(主)键值?</h5>
<p>insert 方法总是返回一个int值，这个值代表的是插入的行数。<br>
通过属性usegeneratedkeys=”true”和keyproperty=”id”来获取生成的键值，自动生成的键值被传入的参数对象中。</p>
<p>useGeneratedKeys： 是否自动生成主键，默认false<br>
keyProperty ：返回的主键值赋给哪个属性<br>
keyColumn： 数据库中的自增主键的列名，默认是数据库表的第一列。当主键列不是表中的第一列的时候需要设置，PostgreSQL必须设置。<br>
主键自动生成，取决于数据库是否支持自增主键。实际上当设置了useGeneratedKeys=“true”，Mybatis会调用JDBC的getGeneratedKeys方法，并将获取的主键值赋值给keyProperty 指定的属性。</p>
<h5 id="在-Mapper-中如何传递多个参数">在 Mapper 中如何传递多个参数?</h5>
<p>​	**第一种：DAO 层的函数：**对应的 xml,#{0}代表接收的是 dao 层中的第一个参数，#{1}代表 dao 层中第二参数，更多参数一致往后加即可。</p>
<p>​	<strong>第二种： 使用 @param 注解：</strong><code>#{}</code>里面的名称对应的是注解<code>@Param</code>括号里面修饰的名称。</p>
<p>​	<strong>第三种：</strong> <strong>Map传参法：</strong><code>#{}</code>里面的名称对应的是<code>Map</code>里面的key名称。</p>
<p>​	<strong>第四种：Java Bean传参法：</strong><code>#{}</code>里面的名称对应的是<code>User</code>类里面的成员属性。</p>
<h5 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？">Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h5>
<p>​	Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor</p>
<p>​	SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。<br>
ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。<br>
​	BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。<br>
作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内</p>
<h5 id="Mybatis是如何进行分页的？分页插件的原理是什么？">Mybatis是如何进行分页的？分页插件的原理是什么？</h5>
<blockquote>
<p>1.<strong>SQL 分页</strong>使用Map来进行包装数据实现分页功能</p>
<p>2.<strong>使用RowBounds来实现分页</strong>，Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>3.<strong>使用拦截器分页</strong>，通过自定义插件的形式实现分页，也是最好的，也叫做分页拦截器。</p>
</blockquote>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的SQL，然后重写SQL，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<h5 id="简述Mybatis的插件运行原理，以及如何编写一个插件">简述Mybatis的插件运行原理，以及如何编写一个插件</h5>
<p>​	Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>​	实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法并在配置文件中配置你编写的插件。</p>
<h5 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？">Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5>
<p>​	第一种是使用 <resultMap> 标签，逐一定义数据库列名和对象属性名之间的映射关系。</resultMap></p>
<p>​	第二种是使用SQL列的别名功能，将列的别名书写为对象属性名。</p>
<p>​	有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h5 id="为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？">为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h5>
<p>Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具</p>
<p>1、全自动完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql，而半自动仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</p>
<p>2、全自动数据库移植性远大于半自动</p>
<p>3、SQL直接优化上，半自动要比全自动方便很多</p>
<p>4、半自动后期维护比全自动更方便</p>
<p>5、 MyBatis的对象关系映射配置灵活，Hibernate则需要配置完整的对象关系映射，对象关系维护的更好。业务表的关联太多，建议使用MyBatis。</p>
<h5 id="MyBatis-实现一对一有几种方式-具体怎么操作的？">MyBatis 实现一对一有几种方式?具体怎么操作的？</h5>
<p>有联合查询和嵌套查询</p>
<p>​	联合查询是几个表联合查询，只查询一次,，通过在resultMap里面配置association节点配置一对一的类就可以完成。</p>
<p>​	嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，通过association配置，但另外一个表的查询通过select属性配置。</p>
<h5 id="MyBatis-实现一对多有几种方式-怎么操作的？">MyBatis 实现一对多有几种方式,怎么操作的？</h5>
<p>有联合查询和嵌套查询。</p>
<p>​	联合查询是几个表联合查询，只查询一次，通过在resultMap里面的collection节点配置一对多的类就可以完成。</p>
<p>​	嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，通过配置collection，但另外一个表的查询通过select节点配置。</p>
<h5 id="数据库链接中断如何处理？">数据库链接中断如何处理？</h5>
<p>数据库的访问底层是通过tcp实现的，当链接中断是程序是无法得知，导致程序一直会停顿一段时间在这，最终会导致用户体验不好。</p>
<p>connection操作底层是一个循环处理操作，因此可以进行时间有关的参数：</p>
<ul>
<li>max_idle_time ： 表明最大的空闲时间，超过这个时间socket就会关闭</li>
<li>connect_timeout ： 表明链接的超时时间</li>
</ul>
<blockquote>
<p>数据库服务器活的杠杠的，但是因为网络用塞，客户端仍然连不上服务器端，这个时候就要设置timeout，别一直傻等着</p>
</blockquote>
<h5 id="在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？">在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？</h5>
<blockquote>
<p>插入的过程一般都是分两步的：先判断是否存在记录，没有存在则插入否则不插入。如果存在并发操作，那么同时进行了第一步，然后大家都发现没有记录，然后都插入了数据从而造成数据的重复。</p>
<p>在分布式环境中通过Redis分布式锁解决即可，多线程环节下用普通的Lock锁解决即可</p>
</blockquote>
<h5 id="事务执行过程中宕机的应对处理方式">事务执行过程中宕机的应对处理方式</h5>
<p>可以依据事务日志进行回滚或者进行执行。</p>
<p>事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化 ，两种类型：</p>
<blockquote>
<p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。</p>
</blockquote>
<ul>
<li>redo log ：按语句的执行顺序，依次交替的记录在一起</li>
<li>undo log： 主要为事务的回滚服务。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</li>
</ul>
<h5 id="Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？">Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？</h5>
<p>​	Java客户端中的一个Connection<strong>不是</strong>在MySQL中就对应一个线程来处理这个链接，而是通过<strong>监听socket的主线程+线程池里面固定数目的工作线程来处理的。</strong></p>
<p>高性能服务器端开发底层主要靠I/O复用来处理，这种模式是：</p>
<blockquote>
<p><strong>单线程+事件处理机制</strong></p>
</blockquote>
<p>​	在MySQL有一个主线程，这是单线程，它不断的循环查看是否有socket是否有读写事件，如果有读写事件，再从线程池里面找个工作线程处理这个socket的读写事件，完事之后工作线程会回到线程池。</p>
<h3 id="Spring面试题">Spring面试题</h3>
<h5 id="spring-提供了哪些配置方式？">spring 提供了哪些配置方式？</h5>
<ul>
<li>基于 xml 配置
<ul>
<li>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。</li>
</ul>
</li>
<li>基于注解配置
<ul>
<li>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。</li>
</ul>
</li>
<li>基于 Java API 配置
<ul>
<li>Spring 的 Java 配置是通过使用@Bean 和 @Configuration 来实现。</li>
</ul>
</li>
</ul>
<h5 id="Spring-Framework-有哪些不同的功能？">Spring Framework 有哪些不同的功能？</h5>
<ul>
<li><strong>轻量级</strong> - Spring 在代码量和透明度方面都很轻便。</li>
<li><strong>IOC</strong> - 控制反转</li>
<li><strong>AOP</strong> - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li><strong>容器</strong> - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li><strong>MVC</strong> - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li><strong>事务管理</strong> - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li><strong>JDBC 异常</strong> - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h5 id="解释一下什么是-aop？什么是IOC？">解释一下什么是 aop？什么是IOC？</h5>
<p>AOP ：面向切面编程，是面向对象开发的一种补充，也是Spring框架中的一个重要内容。它允许开发人员在不改变原来模型的以满足新的需求 ，例如，开发人员可以在不改变原来业务逻辑模型的基础可以进行动态的增加日志，安全或异常处理功能。从而使得业务逻辑各部分之间的耦合度降低，提供程序的可重用性，同时提高了开发的效率。</p>
<p>IOC ：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。</p>
<h5 id="什么是aop，aop的作用是什么-aop中的关键名词有些那些，相互关系是什么">什么是aop，aop的作用是什么?aop中的关键名词有些那些，相互关系是什么?</h5>
<p>​	AOP就是面向切面编程，它可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。</p>
<p>​	作用是让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。</p>
<h5 id="说下对IOC容器的理解以及IOC容器是怎么工作的？">说下对IOC容器的理解以及IOC容器是怎么工作的？</h5>
<p>说下对IOC容器的理解</p>
<ul>
<li>就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。</li>
</ul>
<p>IOC容器是怎么工作的？</p>
<ul>
<li>在配置文件中声明Bean定义也就是为Bean配置元数据，IOC容器的Bean Reader读取并解析配置文件，根据定义生成BeanDefinition配置元数据对象，IOC容器根据BeanDefinition进行实例化、配置及组装Bean。由客户端实例化容器，获取需要的Bean。</li>
</ul>
<h5 id="Spring中AOP-有哪些实现方式？">Spring中AOP 有哪些实现方式？</h5>
<ul>
<li>配置ProxyFactoryBean，显式地设置advisors, advice, target等</li>
<li>配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</li>
<li>通过&lt;aop: config&gt;来配置（纯POJO切面）</li>
<li>通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</li>
</ul>
<h5 id="简述-Spring-IoC-的实现机制？">简述 Spring IoC 的实现机制？</h5>
<p>​	<strong>spring ioc指的是控制反转，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。交由Spring容器统一进行管理，从而实现松耦合</strong>，<strong>“控制反转”，不是什么技术，而是一种设计思想。</strong></p>
<p>​	Spring IoC实现机制简单来说就是工厂模式加反射机制， 在spring初始化的时候 , 初始化所有bean , 然后在应用程序需要的时候 , 通过反射机制来获取</p>
<h5 id="Spring-Bean-在容器的生命周期是什么样的？简单的说一下spring的生命周期？">Spring Bean 在容器的生命周期是什么样的？简单的说一下spring的生命周期？</h5>
<p><img src="/blog/posts/1591749067/1586619066544.png" alt="1586619066544"></p>
<ol>
<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li>
<li>Bean实例化后对将Bean的引入和值注入到Bean的属性中</li>
<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</li>
<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>
<li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</li>
<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</li>
</ol>
<h5 id="Spring中的bean都有哪些作用域？">Spring中的bean都有哪些作用域？</h5>
<ul>
<li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li>
<li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li>
<li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li>
<li>session：同一个 Session 共享一个 bean 实例。</li>
<li>global-session：同 session 作用域不同的是，所有的Session共享一个Bean实例。</li>
</ul>
<h5 id="解释一下Spring-AOP里面的几个名词？">解释一下Spring AOP里面的几个名词？</h5>
<ul>
<li>切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</li>
<li>连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。</li>
<li>通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以<strong>拦截器</strong>做通知模型， 并维护一个以连接点为中心的拦截器链。</li>
<li>切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add*、search*。</li>
<li>引入（Introduction）：声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</li>
<li>目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</li>
<li>织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</li>
</ul>
<h5 id="aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理">aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理</h5>
<p>​	aop的底层实现？</p>
<p>​		AOP的核心机制通过动态代理来实现(jdk动态代理和cglib动态代理)</p>
<p>​	动态代理是如何动态？</p>
<p>​		1.<strong>使用接口(动态代理)</strong></p>
<p>​				如果被代理的对象是面向接口编程的,那么Spring直接使用实现这些接口,然后把需要插入的内容在这个接口上下文中插入</p>
<p>​		2.<strong>使用继承(CGLIB)</strong></p>
<p>​				如果被代理的对象没有基于接口编程,那么Spring会调用cglib库,通过子类继承的方式,动态插入需要的内容,并且调用父类的方法实现cglib内部拥有一个小的字节码处理框架asm,来转换字节码生成新的类.所以spring调用了cglib,相当于生成了一个被代理对象的子类,来取代被代理对象。</p>
<p>​	如何动态的为这100个对象代理？</p>
<p>​		？</p>
<h5 id="简述一下Spring中的单例Bean的线程安全问题？">简述一下Spring中的单例Bean的线程安全问题？</h5>
<p>​	默认 spring 容器中的 bean 是单例的，当单例中存在竞态条件，即有线程安全问题，所以 spring 管理的 bean 的线程安全跟 bean 的创建作用域和 bean 所在的使用环境是否存在竞态条件有关，spring 并不能保证 bean 的线程安全。</p>
<h5 id="spring的bean配置的几种方式？">spring的bean配置的几种方式？</h5>
<p>​	基于XML的配置，基于注解的配置，基于Java类的配置三种方式。</p>
<h5 id="说说spring的监听器的实现原理？">说说spring的监听器的实现原理？</h5>
<p>​	首先写一个监听器（ApplicationListener实现类）来监听某个事件，原理：使用EventListenerMethodProcessor处理器来解析方法上的@EventListener，然后把监听器加入到容器，只要容器中有相关事件的发布，我们就能监听到这个事件</p>
<h5 id="spring-常用的注入方式有哪些？">spring 常用的注入方式有哪些？</h5>
<p>​	Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：构造方法注入，setter注入，基于注解的注入。</p>
<h5 id="spring-中的-bean-是线程安全的吗？支持几种-bean-的作用域？">spring 中的 bean 是线程安全的吗？支持几种 bean 的作用域？</h5>
<p>​	Spring 不保证 bean 的线程安全。默认 spring 容器中的 bean 是单例的，当单例中存在竞态条件，即有线程安全问题，所以 spring 管理的 bean 的线程安全跟 bean 的创建作用域和 bean 所在的使用环境是否存在竞态条件有关，spring 并不能保证 bean 的线程安全。</p>
<p>Spring支持如下5种作用域：</p>
<ul>
<li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li>
<li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li>
<li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li>
<li>session：同一个 Session 共享一个 bean 实例。</li>
<li>global-session：同 session 作用域不同的是，所有的Session共享一个Bean实例。</li>
</ul>
<h5 id="BeanFactory和ApplicationContext的区别是什么？">BeanFactory和ApplicationContext的区别是什么？</h5>
<p>​	    BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p>
<p>区别：</p>
<ul>
<li>BeanFactroy采用的是延迟加载形式来注入Bean的，在使用到某个Bean时才对该Bean进行加载实例化，这样我们不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean，这样在容器启动时我们就可以发现Spring中存在的配置错误。</li>
<li>BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入。</li>
<li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li>
<li>beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。</li>
</ul>
<h5 id="Spring-Aop和AspecJ-Aop有什么区别？">Spring Aop和AspecJ Aop有什么区别？</h5>
<table>
<thead>
<tr>
<th style="text-align:left">Spring AOP</th>
<th style="text-align:left">AspectJ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">在纯 Java 中实现</td>
<td style="text-align:left">使用 Java 编程语言的扩展实现</td>
</tr>
<tr>
<td style="text-align:left">不需要单独的编译过程</td>
<td style="text-align:left">除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</td>
</tr>
<tr>
<td style="text-align:left">只能使用运行时织入</td>
<td style="text-align:left">运行时织入不可用。支持编译时、编译后和加载时织入</td>
</tr>
<tr>
<td style="text-align:left">功能不强-仅支持方法级编织</td>
<td style="text-align:left">更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等…。</td>
</tr>
<tr>
<td style="text-align:left">只能在由 Spring 容器管理的 bean 上实现</td>
<td style="text-align:left">可以在所有域对象上实现</td>
</tr>
<tr>
<td style="text-align:left">仅支持方法执行切入点</td>
<td style="text-align:left">支持所有切入点</td>
</tr>
<tr>
<td style="text-align:left">代理是由目标对象创建的, 并且切面应用在这些代理上</td>
<td style="text-align:left">在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</td>
</tr>
<tr>
<td style="text-align:left">比 AspectJ 慢多了</td>
<td style="text-align:left">更好的性能</td>
</tr>
<tr>
<td style="text-align:left">易于学习和应用</td>
<td style="text-align:left">相对于 Spring AOP 来说更复杂</td>
</tr>
</tbody>
</table>
<h5 id="spring-JDBC-API-中存在哪些类？">spring JDBC API 中存在哪些类？</h5>
<ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<h5 id="解释spring中不同方式的自动装配">解释spring中不同方式的自动装配</h5>
<p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p>
<ol>
<li>no：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</li>
<li>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li>
<li>byType:通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li>
<li>constructor：这个方式类似于byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类	型，将会抛出异常。</li>
<li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li>
</ol>
<h5 id="ApplicationContext通常的实现是什么？">ApplicationContext通常的实现是什么？</h5>
<ul>
<li>FileSystemXmlApplicationContext：此容器从一个xml文件中加载beans的定义，XML Bean配置文件的全路径名必须提供给它的构造函数。</li>
<li>ClassPathXmlApplicationContext：此容器也从一个xml文件中加载beans的定义，这里你需要正确设置classpath，因为这个容器将在classpath里找bean配置。</li>
<li>WebXmlApplicationContext：此容器加载一个xml文件，次文件定义了一个web应用的所有bean。</li>
</ul>
<h5 id="什么是基于Java的Spring注解配置-给一些常见注解的例子">什么是基于Java的Spring注解配置? 给一些常见注解的例子</h5>
<p>​	基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>
<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。另一个例子是@Required  注解，这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p>
<h5 id="动态代理是什么？在spring中有哪些应用？">动态代理是什么？在spring中有哪些应用？</h5>
<p>动态代理，就是为一个对象提供一种代理来控制对这个对象的访问，在某些情况下，客户不想或者不能直接引用另一个对象，这时候代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<p>Spring中主要使用cglib和jdk动态代理，主要在SpringAop就是基于动态代理来实现的。</p>
<p>jdk动态代理主要使用场景是：被代理的对象有实现的接口</p>
<p>cglib代理主要使用场景是：被代理对象的是类而没有任何接口实现</p>
<h3 id="spring关于事务面试题">spring关于事务面试题</h3>
<h5 id="你使用过Spring的事务吗？是怎么用的？">你使用过Spring的事务吗？是怎么用的？</h5>
<p>使用过基于注解和基于xml配置的事务管理，注解是在业务方法上使用@Transaction注解，将事务规则应用到业务逻辑中。基于xml配置的事物管理是在applicationContext.xml进行配置就可以了</p>
<h5 id="简述一下Spring中的事务的实现方式？">简述一下Spring中的事务的实现方式？</h5>
<ul>
<li>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
<li>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。声明式事务管理又有两种实现方式：基于xml配置文件的方式；另一个实在业务方法上进行@Transaction注解，将事务规则应用到业务逻辑中</li>
</ul>
<h5 id="在spring中有几种事务管理，分别是什么">在spring中有几种事务管理，分别是什么?</h5>
<p>​	Spring有两种事务管理方式：</p>
<p>​		1、编程式：比较灵活，但是代码量大，存在重复的代码比较多，我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法</p>
<p>​		2、声明式：声明式事务管理比编程式更灵活方便，声明式事务管理有两种形式：①配置文件 ②在业务方法上加上@Transaction注解，将事务规则应用到业务逻辑中。</p>
<h5 id="什么是spring-的事务隔离？Spring的事务有哪几种隔离级别-spring-事务实现方式有哪些？">什么是spring 的事务隔离？Spring的事务有哪几种隔离级别? spring 事务实现方式有哪些？</h5>
<p>spring事务的隔离级别</p>
<ul>
<li>Default：使用数据库默认的事务隔离级别</li>
<li>未提交读：允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读</li>
<li>已提交读：允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生</li>
<li>可重复读 ：对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生</li>
<li>串行化的：完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。</li>
</ul>
<p>spring实现事务的方式：</p>
<ul>
<li>编程式事务管理：需要手动编写代码，我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法</li>
<li>声明式事务管理：
<ul>
<li>基于TransactionProxyFactoryBean的方式，需要为每个进行事务管理的类做相应配置</li>
<li>基于AspectJ的XML方式，不需要改动类，在XML文件中配置好即可</li>
<li>基于注解的方式，配置简单，需要在业务层类中添加注解@Transactional</li>
</ul>
</li>
</ul>
<h5 id="Spring如何处理线程并发问题？">Spring如何处理线程并发问题？</h5>
<p>Spring使用ThreadLocal解决线程安全问题</p>
<p>​	在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>
<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<h5 id="动态代理与cglib实现的区别？">动态代理与cglib实现的区别？</h5>
<ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成final</li>
</ul>
<h3 id="SpringMVC面试题">SpringMVC面试题</h3>
<h5 id="springmvc运行流程？">springmvc运行流程？</h5>
<ol>
<li>用户发起请求到前端控制器（DispatcherServlet）</li>
<li>前端控制器（DispatcherServlet）请求处理器映射器（HandlerMapping）查找Handler，可以是根据xml查找，也可以是根据注解查找</li>
<li>处理器映射器（HandlerMapping）向前端控制器（DispatcherServlet）返回Handler</li>
<li>前端控制器调用处理器适配器去执行Handler</li>
<li>处理器适配器去执行Handler</li>
<li>Handler执行完成给适配器返回ModelAndView</li>
<li>处理器适配器向前端控制器返回ModelAndView。（ ModelAndView是springmvc框架的一个底层对象，包括Model和view）</li>
<li>前端控制器（DispatcherServlet）请求视图解析器（ViewReslover）去进行视图解析（根据逻辑视图解析成真正的物理视图 Jsp等）</li>
<li>视图解析器（ViewReslover）向前端控制器返回具体 View 对象。</li>
<li>前端控制器（DispatcherServlet）对 View 进行渲染视图（即将模型数据填充至request域）。</li>
<li>前端控制器（DispatcherServlet）向用户响应结果</li>
</ol>
<h5 id="Spring-MVC的主要组件有哪些？分别简述一下">Spring MVC的主要组件有哪些？分别简述一下</h5>
<p>前端控制器（DispatcherServlet）：主要负责捕获来自客户端的请求和调度各个组件。</p>
<p>处理器映射器（HandlerMapping）：根据url查找后端控制器Handler。</p>
<p>处理器适配器（HandlerAdapter）：执行后端控制器（Handler），拿到后端控制器返回的结果ModelAndView后将结果返回给前端控制器DispatcherServlet。</p>
<p>后端控制器（处理器）（Handler）：主要负责处理前端请求，完成业务逻辑，生成ModelAndView对象返回给HandlerAdapter。</p>
<p>视图解析器（ViewResolver）：主要负责将从DispatcherServlet中拿到的ModelAndView对象进行解析，生成View对象返回给DispatcherServlet。</p>
<h5 id="如何解决POST请求中文乱码问题，GET的又如何处理呢？">如何解决POST请求中文乱码问题，GET的又如何处理呢？</h5>
<p>解决post请求乱码问题：</p>
<p>​	在web.xml中配置一个CharacterEncodingFilter过滤器，设置成UTF-8。</p>
<p>get请求中文参数出现乱码解决方法有两个：</p>
<p>​	①修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<p>​		&lt;ConnectorURIEncoding=“UTF-8” connectionTimeout=“20000” port=“8080” protocol=“HTTP/1.1” redirectPort=“8443”/&gt;</p>
<p>​	②另外一种方法对参数进行重新编码：</p>
<p>​		String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),“utf-8”)</p>
<p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p>
<h5 id="SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h5>
<p>默认是单例模式的。</p>
<p>所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能的。</p>
<p>解决方案是在控制器里面不能写成员变量。</p>
<h5 id="6、-SpringMVC常用的注解有哪些？">6、 SpringMVC常用的注解有哪些？</h5>
<h5 id="7、SpringMvc里面拦截器是怎么写？">7、SpringMvc里面拦截器是怎么写？</h5>
<h5 id="8、springmvc-DispatcherServlet与handlerAdapter如何关联">8、springmvc DispatcherServlet与handlerAdapter如何关联?</h5>
<h5 id="9、有了springmvc的IOC容器-还需要spring的IOC容器吗-为什么-如何处理兼容问题">9、有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?</h5>
<h5 id="10、Spring-MVC-怎么做异常处理？">10、Spring MVC 怎么做异常处理？</h5>
<h3 id="Java线程有关面试题">Java线程有关面试题</h3>
<h5 id="简单说说线程的几种状态-以及线程的阻塞的方式">简单说说线程的几种状态 以及线程的阻塞的方式</h5>
<p><strong>Java中线程的状态分为5种：</strong></p>
<p>​	<strong>新建状态</strong>：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新建状态，通过调用start方法进入就绪状态<br>
​	<strong>就绪状态</strong>：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU，一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</p>
<p>​	<strong>运行状态</strong>：线程获得了cpu的调度，执行run()方法中的任务。</p>
<p>​	<strong>阻塞状态</strong>：处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，让出CPU并暂时停止自己的运行。</p>
<p>​	<strong>死亡状态</strong>：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。</p>
<p><strong>阻塞的方式：</strong></p>
<p>​	线程睡眠：Thread.<strong>sleep</strong> (long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位</p>
<p>​	线程等待：Object类中的**wait()**方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。</p>
<p>​	线程自闭，**join()**方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
<h5 id="线程有哪些状态？并简单解释一下每个状态">线程有哪些状态？并简单解释一下每个状态</h5>
<ol>
<li>
<p>**新建(NEW)：**新创建了一个线程对象。</p>
</li>
<li>
<p><strong>运行(RUNNABLE)</strong>：包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程可能正在运行，也可能正在等待系统资源，如等待CPU为它分配时间片。</p>
</li>
<li>
<p><strong>阻塞(BLOCKED)</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。</p>
</li>
<li>
<p><strong>WAITING(等待)</strong>：线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
</li>
<li>
<p><strong>TIME_WAITING(超时等待)</strong>：该状态不同于WAITING，它可以在指定的时间内自行返回。</p>
</li>
<li>
<p><strong>TERMINATED(终止)</strong>：该线程已经执行完毕。</p>
</li>
</ol>
<h5 id="什么是多线程环境下的伪共享（false-sharing）？">什么是多线程环境下的伪共享（false sharing）？</h5>
<p>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。</p>
<p>伪共享发生在不同处理器上的线程对变量的修改依赖于相同的缓存行</p>
<p>缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
<h5 id="线程安全的单例模式是怎么实现的？-原理是什么？">线程安全的单例模式是怎么实现的？ 原理是什么？</h5>
<p>​	作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类，单例模式创建方式分为两大类，饿汉式和懒汉，其中饿汉式比较简单，懒汉式则需要考虑线程安全。</p>
<p>通过如下几种方式可以实现线程安全：</p>
<p>​	1、方法中声明synchronized关键字，对单例执行方法进行锁同步</p>
<p>​	2、使用同步代码块实现实现，3、Double Check Locking 双检查锁机制</p>
<p>​	4、使用静态内置类实现单例模式</p>
<p>​	5、序列化与反序列化的单例模式实现</p>
<p>​	6、使用static代码块实现单例</p>
<p>​	7、使用枚举数据类型实现单例模式</p>
<p>​	8、完善使用enum枚举实现单例模式</p>
<h5 id="线程中wait-和sleep-的区别？">线程中wait 和sleep 的区别？</h5>
<ol>
<li>sleep()方法是线程类（Thread）的静态方法，wait()方法是Object类里的方法。</li>
<li>sleep()方法不会释放锁，wait()方法释放对象锁。</li>
<li>sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用。</li>
<li>sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。</li>
</ol>
<h5 id="BIO、NIO、AIO-有什么区别？">BIO、NIO、AIO 有什么区别？</h5>
<p>​	BIO：同步并阻塞，服务器的实现模式是一个连接一个线程，这样的模式很明显的一个缺陷是：由于客户端连接数与服务器线程数成正比关系，可能造成不必要的线程开销，严重的还将导致服务器内存溢出。当然，这种情况可以通过线程池机制改善，但并不能从本质上消除这个弊端。<br>
​</p>
<p>​	NIO：它是同步非阻塞的。而服务器的实现模式是多个请求一个线程，即请求会注册到多路复用器Selector上，多路复用器轮询到连接有IO请求时才启动一个线程处理。</p>
<p>​	AIO：真正意义上的异步非阻塞，服务器的实现模式为多个有效请求一个线程，客户端的IO请求都是由OS先完成再通知服务器应用去启动线程处理（回调）。</p>
<h5 id="讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势">讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势</h5>
<p>​	多线程并发对同一数据操作时，会有概率产生脏数据，从而会有意外情况发生。</p>
<p>​	解决：实现线程安全的方式有多种，其中在源码中常见的方式是，采用synchronized关键字给代码块或方法加锁，但使用了synchronized 代码块，会导致每次都要进行判断处理，降低了执行效率</p>
<h5 id="请说出你所知道的线程同步的方法">请说出你所知道的线程同步的方法</h5>
<ol>
<li>同步方法：即有synchronized关键字修饰的方法，由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前需要获得内置锁，否则就处于阻塞状态。</li>
<li>同步代码块：即有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。</li>
<li>使用特殊域变量(volatile)实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值 ，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。</li>
<li>使用重入锁实现线程同步：在JavaSE5.0中新增了一个java.util.concurrent包来支持同步，ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。</li>
<li>使用局部变量实现线程同步：如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li>
</ol>
<h5 id="java有哪些锁？乐观锁-悲观锁-synchronized-可重入锁-读写锁-用过reentrantlock吗？reentrantlock与synmchronized的区别">java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别</h5>
<p><strong>Java有哪些锁？</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">公平锁：是指按照申请锁的顺序来获取锁</span><br><span class="line">非公平所：线程获取锁的顺序不一定按照申请锁的顺序来的。</span><br><span class="line">独享锁：一次只能被一个线程所访问</span><br><span class="line">共享锁：线程可以被多个线程所持有。</span><br><span class="line">乐观锁：对于一个数据的操作并发，是不会发生修改的。在更新数据的时候，会尝试采用更新，不断重入的方式，更新数据。</span><br><span class="line">悲观锁：对于同一个数据的并发操作，是一定会发生修改的。因此对于同一个数据的并发操作，悲观锁采用加锁的形式。悲观锁认为，不加锁的操作一定会出问题，</span><br><span class="line">分段锁：<span class="number">1.7</span>及之前的concurrenthashmap。并发操作就是分段锁，其思想就是让锁的粒度变小。</span><br><span class="line">偏向锁：是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价</span><br></pre></td></tr></table></figure>
<p><strong>reentrantlock与synmchronized的区别</strong>？</p>
<p>​	ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。</p>
<p>Lock使用起来比较灵活，但是必须有释放锁的配合动作，Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁，Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等。此外，reentrantlock有trylock 和lockinterruptly ，所以对锁的操作更灵活。从功能的角度看，reentrantlock支持公平锁和非公平锁 而synchronized 仅支持非公平锁。</p>
<h5 id="说说你了解的ThreadLocal的使用场景">说说你了解的ThreadLocal的使用场景</h5>
<p>​	当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。</p>
<h5 id="为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）">为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）</h5>
<p>​	start方法其实是在一个新的操作系统线程上面去调用run方法。换句话说，直接调用run方法而不是调用start方法的话，它并不会开启新的线程，而是在调用run的当前的线程当中执行你的操作。</p>
<p>调用start() 后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，就是为了实现多线程的优点，没这个start不行。</p>
<h5 id="java程序中怎么保证多线程的运行安全？">java程序中怎么保证多线程的运行安全？</h5>
<p>线程的安全性问题体现在：</p>
<p>​	原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作<br>
​	可见性：一个线程对主内存的修改可以及时地被其他线程看到<br>
​	有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</p>
<p>解决办法：<br>
JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题<br>
synchronized、volatile、LOCK，可以解决可见性问题<br>
Happens-Before 规则可以解决有序性问题</p>
<h5 id="什么是死锁？怎么防止死锁">什么是死锁？怎么防止死锁</h5>
<p>​	线程死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p>
<p>产生死锁的四个必要条件：</p>
<ol>
<li>
<p>**互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
</li>
<li>
<p>**请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
</li>
<li>
<p>**不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
</li>
<li>
<p>**循环等待条件：**若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ol>
<p>如何防止：</p>
<p>​	在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<h5 id="synchronized-、-volatile-、Lock-、ReentrantLock-的区别是什么？">synchronized 、 volatile 、Lock 、ReentrantLock  的区别是什么？</h5>
<p>Synchronized和volatile的比较</p>
<ol>
<li>
<p><strong>Synchronized保证内存可见性和操作的原子性，Volatile只能保证内存可见性。</strong></p>
</li>
<li>
<p><strong>volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。）</strong></p>
</li>
<li>
<p><strong>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）</strong></p>
</li>
<li>
<p><strong>volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符</strong></p>
</li>
</ol>
<p>Lock与synchronized的比较</p>
<ol>
<li>
<p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
</li>
<li>
<p>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生。Lock在发生异常时，如果没有主动通过unLock()方法去释放锁，则很可能造成死锁的现象，因此使用Lock时需要在finally块中释放锁</p>
</li>
<li>
<p>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断</p>
</li>
<li>
<p>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</p>
</li>
<li>
<p>Lock可以提高多个线程进行读操作的效率。</p>
</li>
</ol>
<p>Synchronized和ReentrantLock的区别</p>
<ol>
<li><code>ReentrantLock</code>显示获得、释放锁，<code>synchronized</code>隐式获得释放锁</li>
<li><code>ReentrantLock</code>可响应中断、可轮回，<code>synchronized</code>是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</li>
<li><code>ReentrantLock</code>是<code>API</code>级别的，<code>synchronized</code>是<code>JVM</code>级别的</li>
</ol>
<h3 id="Java相关问题面试题">Java相关问题面试题</h3>
<h5 id="Java中如何实现跨域？">Java中如何实现跨域？</h5>
<p>​	首先使用过滤器获取请求对象request的信息，比如Origin 字段（表示请求来自哪个源，包括协议、域名、端口），通过预先配置的参数判断请求是否合法，然后设置响应对象response的头信息，从而实现跨域资源请求。</p>
<h5 id="java中操作字符串都有哪些类？它们之间有什么区别？">java中操作字符串都有哪些类？它们之间有什么区别？</h5>
<p>String、StringBuffer、StringBuilder</p>
<p><strong>String</strong> : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。</p>
<p><strong>StringBuffer</strong> : 对字符串的操作的方法都加了synchronized，保证线程安全。</p>
<p><strong>StringBuilder</strong> : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。</p>
<h5 id="两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？">两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？</h5>
<p>​	不会。<strong>Java里方法的参数传递方式只有一种：值传递。</strong></p>
<h5 id="一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁">一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁</h5>
<p>​	可用jedisLock—redis分布式锁实现：<strong>基本原理</strong>：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</strong></p>
<h5 id="简述-tcp-和-udp的区别？">简述 tcp 和 udp的区别？</h5>
<ol>
<li>TCP面向连接（如打电话要先拨号建立连接）UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，即不保证可靠交付</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的。UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP对系统资源要求较多相对于UDP速度慢一点，UDP对系统资源要求较少。</li>
<li>TCP是面向字节流的，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的。TCP是全双工的可靠信道，UDP是不可靠信道</li>
</ol>
<h5 id="什么是-CSRF-攻击，如何避免？">什么是 CSRF 攻击，如何避免？</h5>
<p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，达到攻击目的。比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>
<p>避免方法：<br>
1. CSRF 漏洞进行检测的工具，如 CSRFTester、CSRF Request Builder…</p>
<ol start="2">
<li>验证 HTTP Referer 字段</li>
<li>在请求地址中添加 token 并验证</li>
<li>添加自定义 http 请求头</li>
<li>敏感操作添加验证码</li>
<li>使用 post 请求</li>
<li>只使用JSON API</li>
</ol>
<h5 id="tcp为什么要三次握手，两次不行吗？为什么？">tcp为什么要三次握手，两次不行吗？为什么？</h5>
<p>什么是三次握手?</p>
<p>​	第一次握手：客户端发送TCP包，置SYN标志位为1，将初始序号X，保存在包头的序列号(Seq)里。</p>
<p>​	第二次握手：服务端回应确认包，置SYN标志位为1，置ACK为X+1，将初始序列号Y，保存在包头的序列号里。<br>
​	第三次握手：客户端对服务端的确认包进行确认，置SYN标志位为0，置ACK为Y+1，置序列号为Z。</p>
<p>为什么要三次握手？</p>
<ul>
<li>
<p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>
</li>
<li>
<p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p>
</li>
</ul>
<p>两次不行吗？为什么？</p>
<p>​	因为我们不进行第三次握手在服务端对客户端请求进行回应后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务端的回应呢？此时客户端仍认为连接未建立，服务端会对已建立的连接保存必要的资源，如果大量的这种情况，服务端会崩溃。因此第三次握手是必要的。</p>
<h5 id="java中数组在内存中如何分配？">java中数组在内存中如何分配？</h5>
<p>​	在使用“new”创建对象时，会在堆中分配一个内存空间并返回一个引用。对于数组也是如此，因为数组是Java中的对象。</p>
<h5 id="为什么重写equals时必须重写hashCode方法？">为什么重写equals时必须重写hashCode方法？</h5>
<ol>
<li>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</li>
<li>保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</li>
<li>如果只重写了 equals 方法，两个对象 equals 返回了true，集合是不允许出现重复元素的，只能插入一个。</li>
</ol>
<h5 id="解释Java堆空间及GC"><strong>解释Java堆空间及GC</strong></h5>
<p>​	Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。<br>
​	在 Java 中，堆被划分成两个不同的区域：新生代和老年代。而新生代又可以划分为Eden区、SurvivorFrom区、SurvivorTo区。而整个区域的比例应该是新生代比老年代为1:2，而Eden比SurvivorFrom比SurvivorTo为8:1:1。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<p>​	Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法，它是java虚拟机自己使用的守护线程。负责清理所谓的&quot;不可达&quot;的对象。当程序创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。当GC确定一些对象为&quot;不可达&quot;时，GC就有责任回收这些内存空间。</p>
<h5 id="谈谈你对Java垃圾回收机制的了解">谈谈你对Java垃圾回收机制的了解</h5>
<p>​	在系统运行过程中，会产生一些无用的对象，这些对象占据着一定的内存，如果不对这些对象清理回收无用对象的内存，可能会导致内存的耗尽，所以垃圾回收机制回收的是内存。同时GC回收的是堆区和方法区的内存。在CPU空闲时或者堆内存满了就会自动调用System.gc()进行回收，一共有标记－清理，标记 - 复制，标记－整理，分代<strong>回收机制</strong>，多种垃圾回收算法。</p>
<h5 id="讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类">讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类</h5>
<p><strong>static</strong></p>
<p>​	1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</p>
<p>​	2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</p>
<p>​	3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</p>
<p>​	4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p>
<p><strong>final</strong></p>
<p>​	1、final修饰一个类时，表明这个类不能被继承。</p>
<p>​	2、final修饰方法，方法不可以重写，但是可以被子类访问 【前提：方法不是 private 类型】。</p>
<p>​	3、如果被final修饰的是<strong>基本数据类型</strong>的变量，则其数值一旦在初始化之后便不能更改；如果是<strong>引用类型</strong>的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>
<p>Java中使用final修饰的类：String，Math，Integer等，这样可以防止对系统造成危害。</p>
<h3 id="Java集合面试题">Java集合面试题</h3>
<h5 id="List-和-Set-的区别？">List 和 Set 的区别？</h5>
<p>1、重复对象：<br>
list方法可以允许重复的对象，set方法不允许重复对象</p>
<p>2、可插入的null元素不同：<br>
list可以插入多个null元素，而set值允许插入一个null元素</p>
<p>3、容器是否有序不同：<br>
list是有序容器，保持每个元素的插入顺序，即输出顺序就是输入顺序，而set方法	是无序容器，无法保证每个元素的存储顺序，TreeSet通过Compaator或者 Comparable维护一个排序顺序</p>
<p>4、常用的实现类不同：<br>
list方法常用的实现类有ArrayList、LinkedList 和 Vector。其中ArrayList 最为流行，它提供了使用索引的随意访问，而LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适，Vector 表示底层数组，线程安全</p>
<p>​    Set方法中最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和compareTo() 的定义进行排序的有序容器</p>
<h5 id="HashSet-是如何保证不重复的">HashSet 是如何保证不重复的</h5>
<p>​	首先会调用Object的hashCode方法判hashCode是否已经存在，如不存在则直接插入元素；</p>
<p>​	如果已存在则调用Object对象的equals方法判断是否返回true，如果为true则说明元素已经存在，如为false则插入元素。</p>
<p>HashSet在内部实例化了一个HashMap对象。HashMap的key是不能重复的，而这里HashSet的元素又是作为了map的key，当然也不能重复了。</p>
<h4 id="java中几种集合的区别以及底层实现是什么样的？">java中几种集合的区别以及底层实现是什么样的？</h4>
<p>Java中的集合包括三大类，它们是Set、List和Map，它们都处于java.util包中，Set、List和Map都是接口，它们有各自的实现类。Set的实现类主要有HashSet和TreeSet，List的实现类主要有ArrayList，Map的实现类主要有HashMap和TreeMap。</p>
<h5 id="ArrayList实现原理">ArrayList实现原理</h5>
<ol>
<li>ArrayList是List接口的可变数组非同步实现，并允许包括null在内的所有元素。</li>
<li>底层使用数组实现</li>
<li>该集合是可变长度数组，数组扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量增长大约是其容量的1.5倍，这种操作的代价很高。</li>
<li>采用了Fail-Fast机制，面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li>
<li>remove方法会让下标到数组末尾的元素向前移动一个单位，并把最后一位的值置空，方便GC</li>
</ol>
<h5 id="HashMap实现原理">HashMap实现原理</h5>
<ol>
<li>HashMap是基于哈希表的Map接口的非同步实现，允许使用null值和null键，但不保证映射的顺序。</li>
<li>底层使用数组实现，数组中每一项是个单向链表，即数组和链表的结合体；当链表长度大于一定阈值时，链表转换为红黑树，这样减少链表查询时间。</li>
<li>HashMap在底层将key-value当成一个整体进行处理，这个整体就是一个Node对象。HashMap底层采用一个Node[]数组来保存所有的key-value对，当需要存储一个Node对象时，会根据key的hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Node时，也会根据key的hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Node。</li>
<li>HashMap进行数组扩容需要重新计算扩容后每个元素在数组中的位置，很耗性能</li>
<li>采用了Fail-Fast机制，通过一个modCount值记录修改次数，对HashMap内容的修改都将增加这个值。迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map，马上抛出异常</li>
</ol>
<h5 id="HashSet实现原理">HashSet实现原理</h5>
<ol>
<li>HashSet由哈希表(实际上是一个HashMap实例)支持，不保证set的迭代顺序，并允许使用null元素。</li>
<li>基于HashMap实现，API也是对HashMap的行为进行了封装，可参考HashMap</li>
</ol>
<h4 id="简单说说hashmap的底层实现原理">简单说说hashmap的底层实现原理</h4>
<p>​	首先有一个每个元素都是链表的数组，当添加一个元素时，就首先计算元素key的hash值，以此确定插入数组中的位置，但可能存在同一hash值的元素已经被放到数组的同一位置了，这时就添加到同一hash值的元素后面，他们在数组的同一位置，但是行成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中。</p>
<h3 id="缓存面试题">缓存面试题</h3>
<h5 id="简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？">简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？</h5>
<p>memcache和redis的两种缓存的区别？</p>
<p>​	1、在Redis中，不是所有的数据都一直存储在内存中的，这是和Memcache相比一个最大的区别。</p>
<p>​	2、Reids在很多方面具备数据库的特征， 支持多种数据结构，而Memcache只是简单的K/V缓存。</p>
<p>​	3、在100k以上的数据中，Memcache性能要高于Redis。</p>
<p>​	4、在内存使用效率的话，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcache。当然，这和你的应用场景和数据特性有关。</p>
<p>​	5、存储数据安全—memcache挂掉后，数据没了，redis可以定期保存到磁盘（持久化）</p>
<p>​	6、灾难恢复—memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复</p>
<p><strong>对于两者的选择还是要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，我在项目里还是采用memcache，它也足够的稳定可靠。如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。</strong></p>
<h3 id="MySQL面试题">MySQL面试题</h3>
<h5 id="你了解的Mysql的几种引擎？-分别适合什么样的数据库">你了解的Mysql的几种引擎？ 分别适合什么样的数据库</h5>
<p>MyISAM(默认引擎)：查询性能高，并发修改数据性能低、不支持外键、不支持事务。</p>
<p>INNODB：修改数据性能高，支持事务，支持外键、查询性能相对MyISAM要低;</p>
<p>MEMORY： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p>
<p>分别适用？</p>
<p>​	MyISAM：如果这个数据库中查询要求比较高可以选择MyISAM存储，因为其特性在做数据库读写分离时通常会把读取的表的存储引擎设置为MyISAM。</p>
<p>​	INNODB：如果需要比较高的事务处理，高并发写的业务场景，可以选择InnoDB。</p>
<p>​	MEMORY：如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p>
<h5 id="mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的">mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的</h5>
<p>​	1、避免 SELECT *，需要什么数据，就查询对应的字段。</p>
<p>​	2、利用自增主键索引、<code>order by</code>加<code>limit</code>，不使用offset</p>
<p>​	3、在性能要求比较高的场景中，杜绝查询中使用<code>临时表</code></p>
<p>​	4、使用 EXPLAIN 关键字分析SQL语句性能。</p>
<h5 id="简单讲讲mysql的锁机制以及的行级锁加在哪个位置？">简单讲讲mysql的锁机制以及的行级锁加在哪个位置？</h5>
<p>锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性，MySQL的锁机制最显著的特点是不同的存储引擎支持不同的锁机制，比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；InnoDB存储引擎既支持行级锁（ row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p>
<p>MySQL大致可归纳为以下3种锁：<br>
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>行级锁加在哪个位置？</p>
<p>​	InnoDB行锁是通过给索引上的<code>索引项加锁</code>来实现的。所以，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/posts/1144715794/" rel="prev" title="SpringSecurityOAuth2.0认证授权">
      <i class="fa fa-chevron-left"></i> SpringSecurityOAuth2.0认证授权
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/posts/667971766/" rel="next" title="最近问到的面试题">
      最近问到的面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#null"><span class="nav-number">1.</span> <span class="nav-text">经典面试题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MyBatis面试题"><span class="nav-number">1.0.1.</span> <span class="nav-text">MyBatis面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#和-的区别是什么？"><span class="nav-number">1.0.1.0.1.</span> <span class="nav-text">#{} 和 ${} 的区别是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><span class="nav-number">1.0.1.0.2.</span> <span class="nav-text">介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#介绍一下MyBatis的缓存？"><span class="nav-number">1.0.1.0.3.</span> <span class="nav-text">介绍一下MyBatis的缓存？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MyBatis-执行批量插入有哪些方式？-优缺点是什么"><span class="nav-number">1.0.1.0.4.</span> <span class="nav-text">MyBatis 执行批量插入有哪些方式？ 优缺点是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当实体类中的属性名和表中的字段名不一样时有哪些处理方法？"><span class="nav-number">1.0.1.0.5.</span> <span class="nav-text">当实体类中的属性名和表中的字段名不一样时有哪些处理方法？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><span class="nav-number">1.0.1.0.6.</span> <span class="nav-text">Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><span class="nav-number">1.0.1.0.7.</span> <span class="nav-text">通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mapper接口绑定有几种实现方式-分别是怎么实现的"><span class="nav-number">1.0.1.0.8.</span> <span class="nav-text">Mapper接口绑定有几种实现方式,分别是怎么实现的?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在mybatis中如何获取自动生成的-主-键值"><span class="nav-number">1.0.1.0.9.</span> <span class="nav-text">在mybatis中如何获取自动生成的(主)键值?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在-Mapper-中如何传递多个参数"><span class="nav-number">1.0.1.0.10.</span> <span class="nav-text">在 Mapper 中如何传递多个参数?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><span class="nav-number">1.0.1.0.11.</span> <span class="nav-text">Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mybatis是如何进行分页的？分页插件的原理是什么？"><span class="nav-number">1.0.1.0.12.</span> <span class="nav-text">Mybatis是如何进行分页的？分页插件的原理是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简述Mybatis的插件运行原理，以及如何编写一个插件"><span class="nav-number">1.0.1.0.13.</span> <span class="nav-text">简述Mybatis的插件运行原理，以及如何编写一个插件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><span class="nav-number">1.0.1.0.14.</span> <span class="nav-text">Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><span class="nav-number">1.0.1.0.15.</span> <span class="nav-text">为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MyBatis-实现一对一有几种方式-具体怎么操作的？"><span class="nav-number">1.0.1.0.16.</span> <span class="nav-text">MyBatis 实现一对一有几种方式?具体怎么操作的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MyBatis-实现一对多有几种方式-怎么操作的？"><span class="nav-number">1.0.1.0.17.</span> <span class="nav-text">MyBatis 实现一对多有几种方式,怎么操作的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库链接中断如何处理？"><span class="nav-number">1.0.1.0.18.</span> <span class="nav-text">数据库链接中断如何处理？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？"><span class="nav-number">1.0.1.0.19.</span> <span class="nav-text">在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事务执行过程中宕机的应对处理方式"><span class="nav-number">1.0.1.0.20.</span> <span class="nav-text">事务执行过程中宕机的应对处理方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？"><span class="nav-number">1.0.1.0.21.</span> <span class="nav-text">Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring面试题"><span class="nav-number">1.0.2.</span> <span class="nav-text">Spring面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#spring-提供了哪些配置方式？"><span class="nav-number">1.0.2.0.1.</span> <span class="nav-text">spring 提供了哪些配置方式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-Framework-有哪些不同的功能？"><span class="nav-number">1.0.2.0.2.</span> <span class="nav-text">Spring Framework 有哪些不同的功能？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解释一下什么是-aop？什么是IOC？"><span class="nav-number">1.0.2.0.3.</span> <span class="nav-text">解释一下什么是 aop？什么是IOC？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是aop，aop的作用是什么-aop中的关键名词有些那些，相互关系是什么"><span class="nav-number">1.0.2.0.4.</span> <span class="nav-text">什么是aop，aop的作用是什么?aop中的关键名词有些那些，相互关系是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#说下对IOC容器的理解以及IOC容器是怎么工作的？"><span class="nav-number">1.0.2.0.5.</span> <span class="nav-text">说下对IOC容器的理解以及IOC容器是怎么工作的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring中AOP-有哪些实现方式？"><span class="nav-number">1.0.2.0.6.</span> <span class="nav-text">Spring中AOP 有哪些实现方式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简述-Spring-IoC-的实现机制？"><span class="nav-number">1.0.2.0.7.</span> <span class="nav-text">简述 Spring IoC 的实现机制？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-Bean-在容器的生命周期是什么样的？简单的说一下spring的生命周期？"><span class="nav-number">1.0.2.0.8.</span> <span class="nav-text">Spring Bean 在容器的生命周期是什么样的？简单的说一下spring的生命周期？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring中的bean都有哪些作用域？"><span class="nav-number">1.0.2.0.9.</span> <span class="nav-text">Spring中的bean都有哪些作用域？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解释一下Spring-AOP里面的几个名词？"><span class="nav-number">1.0.2.0.10.</span> <span class="nav-text">解释一下Spring AOP里面的几个名词？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理"><span class="nav-number">1.0.2.0.11.</span> <span class="nav-text">aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简述一下Spring中的单例Bean的线程安全问题？"><span class="nav-number">1.0.2.0.12.</span> <span class="nav-text">简述一下Spring中的单例Bean的线程安全问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring的bean配置的几种方式？"><span class="nav-number">1.0.2.0.13.</span> <span class="nav-text">spring的bean配置的几种方式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#说说spring的监听器的实现原理？"><span class="nav-number">1.0.2.0.14.</span> <span class="nav-text">说说spring的监听器的实现原理？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring-常用的注入方式有哪些？"><span class="nav-number">1.0.2.0.15.</span> <span class="nav-text">spring 常用的注入方式有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring-中的-bean-是线程安全的吗？支持几种-bean-的作用域？"><span class="nav-number">1.0.2.0.16.</span> <span class="nav-text">spring 中的 bean 是线程安全的吗？支持几种 bean 的作用域？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanFactory和ApplicationContext的区别是什么？"><span class="nav-number">1.0.2.0.17.</span> <span class="nav-text">BeanFactory和ApplicationContext的区别是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-Aop和AspecJ-Aop有什么区别？"><span class="nav-number">1.0.2.0.18.</span> <span class="nav-text">Spring Aop和AspecJ Aop有什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#spring-JDBC-API-中存在哪些类？"><span class="nav-number">1.0.2.0.19.</span> <span class="nav-text">spring JDBC API 中存在哪些类？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解释spring中不同方式的自动装配"><span class="nav-number">1.0.2.0.20.</span> <span class="nav-text">解释spring中不同方式的自动装配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ApplicationContext通常的实现是什么？"><span class="nav-number">1.0.2.0.21.</span> <span class="nav-text">ApplicationContext通常的实现是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是基于Java的Spring注解配置-给一些常见注解的例子"><span class="nav-number">1.0.2.0.22.</span> <span class="nav-text">什么是基于Java的Spring注解配置? 给一些常见注解的例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态代理是什么？在spring中有哪些应用？"><span class="nav-number">1.0.2.0.23.</span> <span class="nav-text">动态代理是什么？在spring中有哪些应用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring关于事务面试题"><span class="nav-number">1.0.3.</span> <span class="nav-text">spring关于事务面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#你使用过Spring的事务吗？是怎么用的？"><span class="nav-number">1.0.3.0.1.</span> <span class="nav-text">你使用过Spring的事务吗？是怎么用的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简述一下Spring中的事务的实现方式？"><span class="nav-number">1.0.3.0.2.</span> <span class="nav-text">简述一下Spring中的事务的实现方式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在spring中有几种事务管理，分别是什么"><span class="nav-number">1.0.3.0.3.</span> <span class="nav-text">在spring中有几种事务管理，分别是什么?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是spring-的事务隔离？Spring的事务有哪几种隔离级别-spring-事务实现方式有哪些？"><span class="nav-number">1.0.3.0.4.</span> <span class="nav-text">什么是spring 的事务隔离？Spring的事务有哪几种隔离级别? spring 事务实现方式有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring如何处理线程并发问题？"><span class="nav-number">1.0.3.0.5.</span> <span class="nav-text">Spring如何处理线程并发问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态代理与cglib实现的区别？"><span class="nav-number">1.0.3.0.6.</span> <span class="nav-text">动态代理与cglib实现的区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC面试题"><span class="nav-number">1.0.4.</span> <span class="nav-text">SpringMVC面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#springmvc运行流程？"><span class="nav-number">1.0.4.0.1.</span> <span class="nav-text">springmvc运行流程？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-MVC的主要组件有哪些？分别简述一下"><span class="nav-number">1.0.4.0.2.</span> <span class="nav-text">Spring MVC的主要组件有哪些？分别简述一下</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何解决POST请求中文乱码问题，GET的又如何处理呢？"><span class="nav-number">1.0.4.0.3.</span> <span class="nav-text">如何解决POST请求中文乱码问题，GET的又如何处理呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><span class="nav-number">1.0.4.0.4.</span> <span class="nav-text">SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、-SpringMVC常用的注解有哪些？"><span class="nav-number">1.0.4.0.5.</span> <span class="nav-text">6、 SpringMVC常用的注解有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、SpringMvc里面拦截器是怎么写？"><span class="nav-number">1.0.4.0.6.</span> <span class="nav-text">7、SpringMvc里面拦截器是怎么写？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8、springmvc-DispatcherServlet与handlerAdapter如何关联"><span class="nav-number">1.0.4.0.7.</span> <span class="nav-text">8、springmvc DispatcherServlet与handlerAdapter如何关联?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9、有了springmvc的IOC容器-还需要spring的IOC容器吗-为什么-如何处理兼容问题"><span class="nav-number">1.0.4.0.8.</span> <span class="nav-text">9、有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10、Spring-MVC-怎么做异常处理？"><span class="nav-number">1.0.4.0.9.</span> <span class="nav-text">10、Spring MVC 怎么做异常处理？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java线程有关面试题"><span class="nav-number">1.0.5.</span> <span class="nav-text">Java线程有关面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单说说线程的几种状态-以及线程的阻塞的方式"><span class="nav-number">1.0.5.0.1.</span> <span class="nav-text">简单说说线程的几种状态 以及线程的阻塞的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程有哪些状态？并简单解释一下每个状态"><span class="nav-number">1.0.5.0.2.</span> <span class="nav-text">线程有哪些状态？并简单解释一下每个状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是多线程环境下的伪共享（false-sharing）？"><span class="nav-number">1.0.5.0.3.</span> <span class="nav-text">什么是多线程环境下的伪共享（false sharing）？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程安全的单例模式是怎么实现的？-原理是什么？"><span class="nav-number">1.0.5.0.4.</span> <span class="nav-text">线程安全的单例模式是怎么实现的？ 原理是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程中wait-和sleep-的区别？"><span class="nav-number">1.0.5.0.5.</span> <span class="nav-text">线程中wait 和sleep 的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BIO、NIO、AIO-有什么区别？"><span class="nav-number">1.0.5.0.6.</span> <span class="nav-text">BIO、NIO、AIO 有什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势"><span class="nav-number">1.0.5.0.7.</span> <span class="nav-text">讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请说出你所知道的线程同步的方法"><span class="nav-number">1.0.5.0.8.</span> <span class="nav-text">请说出你所知道的线程同步的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java有哪些锁？乐观锁-悲观锁-synchronized-可重入锁-读写锁-用过reentrantlock吗？reentrantlock与synmchronized的区别"><span class="nav-number">1.0.5.0.9.</span> <span class="nav-text">java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#说说你了解的ThreadLocal的使用场景"><span class="nav-number">1.0.5.0.10.</span> <span class="nav-text">说说你了解的ThreadLocal的使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）"><span class="nav-number">1.0.5.0.11.</span> <span class="nav-text">为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java程序中怎么保证多线程的运行安全？"><span class="nav-number">1.0.5.0.12.</span> <span class="nav-text">java程序中怎么保证多线程的运行安全？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是死锁？怎么防止死锁"><span class="nav-number">1.0.5.0.13.</span> <span class="nav-text">什么是死锁？怎么防止死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#synchronized-、-volatile-、Lock-、ReentrantLock-的区别是什么？"><span class="nav-number">1.0.5.0.14.</span> <span class="nav-text">synchronized 、 volatile 、Lock 、ReentrantLock  的区别是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java相关问题面试题"><span class="nav-number">1.0.6.</span> <span class="nav-text">Java相关问题面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java中如何实现跨域？"><span class="nav-number">1.0.6.0.1.</span> <span class="nav-text">Java中如何实现跨域？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java中操作字符串都有哪些类？它们之间有什么区别？"><span class="nav-number">1.0.6.0.2.</span> <span class="nav-text">java中操作字符串都有哪些类？它们之间有什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？"><span class="nav-number">1.0.6.0.3.</span> <span class="nav-text">两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁"><span class="nav-number">1.0.6.0.4.</span> <span class="nav-text">一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简述-tcp-和-udp的区别？"><span class="nav-number">1.0.6.0.5.</span> <span class="nav-text">简述 tcp 和 udp的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是-CSRF-攻击，如何避免？"><span class="nav-number">1.0.6.0.6.</span> <span class="nav-text">什么是 CSRF 攻击，如何避免？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tcp为什么要三次握手，两次不行吗？为什么？"><span class="nav-number">1.0.6.0.7.</span> <span class="nav-text">tcp为什么要三次握手，两次不行吗？为什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java中数组在内存中如何分配？"><span class="nav-number">1.0.6.0.8.</span> <span class="nav-text">java中数组在内存中如何分配？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么重写equals时必须重写hashCode方法？"><span class="nav-number">1.0.6.0.9.</span> <span class="nav-text">为什么重写equals时必须重写hashCode方法？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解释Java堆空间及GC"><span class="nav-number">1.0.6.0.10.</span> <span class="nav-text">解释Java堆空间及GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#谈谈你对Java垃圾回收机制的了解"><span class="nav-number">1.0.6.0.11.</span> <span class="nav-text">谈谈你对Java垃圾回收机制的了解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类"><span class="nav-number">1.0.6.0.12.</span> <span class="nav-text">讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java集合面试题"><span class="nav-number">1.0.7.</span> <span class="nav-text">Java集合面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#List-和-Set-的区别？"><span class="nav-number">1.0.7.0.1.</span> <span class="nav-text">List 和 Set 的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashSet-是如何保证不重复的"><span class="nav-number">1.0.7.0.2.</span> <span class="nav-text">HashSet 是如何保证不重复的</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java中几种集合的区别以及底层实现是什么样的？"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">java中几种集合的区别以及底层实现是什么样的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList实现原理"><span class="nav-number">1.0.7.1.1.</span> <span class="nav-text">ArrayList实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap实现原理"><span class="nav-number">1.0.7.1.2.</span> <span class="nav-text">HashMap实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashSet实现原理"><span class="nav-number">1.0.7.1.3.</span> <span class="nav-text">HashSet实现原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单说说hashmap的底层实现原理"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">简单说说hashmap的底层实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存面试题"><span class="nav-number">1.0.8.</span> <span class="nav-text">缓存面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？"><span class="nav-number">1.0.8.0.1.</span> <span class="nav-text">简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL面试题"><span class="nav-number">1.0.9.</span> <span class="nav-text">MySQL面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#你了解的Mysql的几种引擎？-分别适合什么样的数据库"><span class="nav-number">1.0.9.0.1.</span> <span class="nav-text">你了解的Mysql的几种引擎？ 分别适合什么样的数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的"><span class="nav-number">1.0.9.0.2.</span> <span class="nav-text">mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简单讲讲mysql的锁机制以及的行级锁加在哪个位置？"><span class="nav-number">1.0.9.0.3.</span> <span class="nav-text">简单讲讲mysql的锁机制以及的行级锁加在哪个位置？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="微笑"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">微笑</p>
  <div class="site-description" itemprop="description">技术博客,Java,记录美好学习时光</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/yourname" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/yourname" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a>
      </span>
  </div>



      </div>

      
       <div>
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="210" height="110" src="//music.163.com/outchain/player?type=2&id=526464145&auto=0&height=66"></iframe>
       </div>
      


      <!-- 添加近期文章 -->
      
        <div class="links-of-blogroll motion-element links-of-blogroll-block">
          <div class="links-of-blogroll-title">
            <!-- modify icon to fire by szw -->
            <i class="fa fa-history fa-" aria-hidden="true"></i>
            近期文章
          </div>
          <ul class="links-of-blogroll-list">
            
            
              <li>
                <a href="/blog/" title="" target="_blank"></a>
              </li>
            
              <li>
                <a href="/blog/" title="" target="_blank"></a>
              </li>
            
              <li>
                <a href="/blog/" title="" target="_blank"></a>
              </li>
            
              <li>
                <a href="/blog/" title="" target="_blank"></a>
              </li>
            
              <li>
                <a href="/blog/" title="" target="_blank"></a>
              </li>
            
          </ul>
        </div>
      
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">微笑</span>
</div>

        <div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

   
    <span class="site-uv">
       我的第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 位朋友，
    </span>
   <span class="agesicon"> <span>
   
   
     <span class="site-pv">
       历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次回眸才与你相遇。
     </span>
   
 
</div>






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=Et7HjwbCekhAgSdgtS4nViuq-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'Et7HjwbCekhAgSdgtS4nViuq-gzGzoHsz',
            'X-LC-Key': '3htjjTDFTKLscCuCqF47i1e6',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='150' src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>














  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'Et7HjwbCekhAgSdgtS4nViuq-gzGzoHsz',
    appKey: '3htjjTDFTKLscCuCqF47i1e6',
    placeholder: "说点什么吧。",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

  <script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script>
  <script>
    function timer() {
      var ages = moment.preciseDiff(moment(),moment(20181001,"YYYYMMDD"));
      //去除时分秒信息
      ages = ages.replace(/\s?\d{0,2}\s+hours?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+minutes?/, "");
      ages = ages.replace(/\s?\d{0,2}\s+seconds?/, "");
      //将年月日转换为中文
      ages = ages.replace(/years?/, "年");
      ages = ages.replace(/months?/, "月");
      ages = ages.replace(/days?/, "天");
      ages = ages.replace(/\d+/g, '<span style="color:#1094e8">$&</span>');
      span.innerHTML = ` &nbsp; | &nbsp;我已在此等候你 ${ages}`;
    }
    var span = document.createElement("span");
    //插入到agesicon之后
    var agesicon = document.querySelector(".agesicon");
    document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling);
    timer();
  </script>
<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/blog/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":250,"height":500},"mobile":{"show":true}});</script></body>
</html>
